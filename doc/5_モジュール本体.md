# 5 モジュール本体

モジュール本体（セクション 4.2）には、本仕様で定義する VBA プログラミング言語の構文で記述されたソースコードが含まれる。本章では、モジュール本体の有効な構文、静的セマンティクス、実行時セマンティクスを定義する。

構文は、セクション 3 で定義された終端記号を組み込んだ ABNF [[RFC4234]](https://go.microsoft.com/fwlink/?LinkId=90462) 文法を用いて記述される。\<LINE-START\> と \<LINE-END\> 要素を明示的に識別する場合を除き、この文法はモジュール本体のソースコードを含むファイルの物理的な行構造を無視する。この文法は、セクション 3.4 で説明するように、条件付きコンパイル指示文と条件付き除外ソースコードも無視する。この文法は前処理されたモジュール本体（セクション 3.4）に適用され、ソースコードは字句トークン化と条件付きコンパイルの両方の前処理が適用されたかのように解釈される。この前処理は本仕様を単純化し明確にするためにのみなされる。実装が実際にこのような処理モデルを使用する必要はない。

## 5.1 モジュール本体の構造

```
procedural-module-body = LINE-START  procedural-module-declaration-section
                         LINE-START  procedural-module-code-section

class-module-body = LINE-START  class-module-declaration-section
                    LINE-START  class-module-code-section
```

プロシージャモジュール（セクション 4.2）とクラスモジュール（セクション 4.2）はともに、宣言部（セクション 5.2）とコード部（セクション 5.3）の二つの部分からなるモジュール本体（セクション 4.2）を持っている。各部分は、それを含むソースファイルの物理的な行の最初の構文要素として<ins>出現しなければならない</ins>。

本仕様では、様々な形式のエンティティ（セクション 2.2）名を表現するために以下の共通文法規則を使用する。

```
unrestricted-name = name / reserved-identifier
name = untyped-name / TYPED-NAME
untyped-name = IDENTIFIER / FOREIGN-NAME
```

## 5.2 モジュール宣言部の構造

モジュール（セクション 4.2）の宣言部は、ディレクティブと宣言から構成される。一般的に、ディレクティブはモジュール内の静的セマンティクスの適用を制御する。宣言はプログラムの実行環境内に存在する名前付きエンティティを定義する。

```
procedural-module-declaration-section = [*(procedural-module-directive-element EOS) def-directive]  *( procedural-module-declaration-element EOS)
class-module-declaration-section = [*(class-module-directive-element EOS) def-directive]  *(class-module-declaration-element EOS)
procedural-module-directive-element = common-option-directive / option-private-directive / def-directive 
procedural-module-declaration-element = common-module-declaration-element / global-variable-declaration / public-const-declaration / public-type-declaration / public-external-procedure-declaration / global-enum-declaration / common-option-directive / option-private-directive

class-module-directive-element = common-option-directive / def-directive / implements-directive
class-module-declaration-element = common-module-declaration-element / event-declaration / commonoption-directive / implements-directive 
```

静的セマンティクス

モジュール宣言部の中でのディレクティブと宣言の出現回数と相対的な順序には様々な制限がある。これらの制限は、個々のディレクティブと宣言の要素の定義の一部として指定される。

### 5.2.1 Option ディレクティブ

`Option` ディレクティブは、様々な言語機能の代替セマンティクスを選択するために使用される。

```
common-option-directive = option-compare-directive /  option-base-directive / option-explicit-directive  / rem-statement
```

静的セマンティクス

- 各 \<common-option-directive\> は、各 \<procedural-module-declaration-section\> または \<class-module-declaration-section\> に最大 1 回まで出現することが可能である。
- \<option-private-directive\> は、各 \<procedural-module-declaration-section\> に最大 1 回まで出現することが可能である。

#### 5.2.1.1 Option Compare ディレクティブ

`Option Compare` ディレクティブは、関係演算子（セクション 5.6.9.5）がモジュール（セクション 4.2）内の文字列データ値（セクション 2.1）に適用される際の比較規則を決定する。これはモジュールの比較モードとして知られている。

```
option-compare-directive = "Option"   "Compare"   ( "Binary" / "Text")
```

静的セマンティクス

- \<option-compare-directive\> が `Binary` キーワード（セクション 3.3.5.1）を含んでいる場合、モジュールの比較モードはバイナリ比較モードになる。
- \<option-compare-directive\> が `Text` キーワードを含んでいる場合、モジュールの比較モードはテキスト比較モードになる。
- \<option-compare-directive\> は \<procedural-module-declaration-section\> や \<class-module-declaration-section\> 内に 1 つだけ存在できる。
- \<procedural-module-declaration-section\> または \<class-module-declaration-section\> が \<option-compare-directive\> を含んでいない場合、そのモジュールの比較モードはバイナリ比較モードとなる。

#### 5.2.1.2 Option Base ディレクティブ

`Option Base` ディレクティブは、モジュール（セクション 4.2）で使用する、\<dim-spec\> の \<lower-bound\> で明示的に指定されていないすべての配列次元の下限（セクション 2.1）にデフォルト値を設定する。

```
option-base-directive = "Option"   "Base"     INTEGER
```

静的セマンティクス

- \<option-base-directive\> は \<procedural-module-declaration-section\> や \<class-module-declaration-section\> 内に最大 1 回まで出現することが可能である。
- もし、\<option-base-directive\> があるならば、同じ \<procedural-module-declaration-section\> や \<class-module-declaration-section\> 内で最初に現れる \<dim-spec\> の前に<ins>なければならない</ins>。
- \<INTEGER\> のデータ値（セクション 2.1）は、整数データ値 0 または 1 のどちらかに<ins>等しくなければならない</ins>。
- それを含むモジュールにおける配列次元のデフォルトの下限値は \<INTEGER\> 要素のデータ値となる。
- \<procedural-module-declaration-section\> や \<class-module-declaration-section\> に \<option-base-directive\> がない場合、モジュール内の配列次元の下限のデフォルト値は 0 となる。

#### 5.2.1.3 Option Explicit ディレクティブ

`Option Explicit` ディレクティブは、変数（セクション 2.3）を包含するモジュール（セクション 4.2）内で暗黙的に宣言（セクション 5.6.10）できるかどうかを制御する変数宣言モードを設定するために使用される。

```
option-explicit-directive = "Option"   "Explicit"
```

静的セマンティクス

- モジュール内に \<option-explicit-directive\> が存在する場合、そのモジュールの変数宣言モードは明示的モードとなる。
- \<option-explicit-directive\> がモジュール内に存在しない場合、モジュールの変数宣言モードは暗黙的モードとなる。
- \<option-explicit-directive\> は \<procedural-module-declaration-section\> または \<class-module-declaration-section\> の中に 1 つだけ存在することが可能である。
- \<procedural-module-declaration-section\> または \<class-module-declaration-section\> に \<option-explicit-directive\> がない場合、そのモジュールの変数宣言モードは暗黙的モードとなる。

#### 5.2.1.4 Option Private ディレクティブ

`Option Private` ディレクティブは、モジュール（セクション 4.2）の他のプロジェクト（セクション 4.1）に対するアクセス制限を制御し、モジュール内で宣言された `Public` エンティティ（セクション 2.2）の公開アクセスの意味も制御する。

```
option-private-directive = "Option"   "Private"   "Module"
```

静的セマンティクス

- プロシージャモジュール（セクション 4.2）に \<option-private-directive\> が含まれている場合、そのモジュール自身は非公開モジュールとみなされ、そのプロジェクト内でのみアクセス可能である。
- プロシージャモジュールに \<option-private-directive\> が含まれていない場合、そのモジュール自体は公開モジュールとみなされ、そのプロジェクト内およびそのプロジェクトを参照しているすべてのプロジェクト内でアクセス可能である。
- モジュールのアクセス制限がモジュール内の宣言のアクセス制限に及ぼす影響については、セクション 5.2.3 の特定のモジュール宣言形式の定義で説明されている。


### 5.2.2 暗黙定義ディレクティブ
```
def-directive = def-type  letter-spec *( "," letter-spec)
letter-spec = single-letter /  universal-letter-range / letter-range

single-letter = IDENTIFIER   ; %x0041-005A / %x0061-007A

universal-letter-range = upper-case-A "-"upper-case-Z
upper-case-A = IDENTIFIER
upper-case-Z = IDENTIFIER

letter-range = first-letter  "-" last-letter
first-letter = IDENTIFIER
last-letter = IDENTIFIER

def-type = "DefBool" / "DefByte" / "DefCur" /  "DefDate" / "DefDbl" / "DefInt" / "DefLng" / "DefLngLng" / "DefLngPtr" / "DefObj" / "DefSng" / "DefStr" / "DefVar"
```

暗黙的定義ディレクティブは、暗黙的に型付けされたエンティティ（セクション 2.2）の宣言型（セクション 2.2）を決定するために、モジュール（セクション 4.2）内で使用される規則を定義する。このようなエンティティの宣言型は、その名称値（セクション 3.3.5.1）の最初の文字に基づいて決定される。暗黙定義ディレクティブは、そのような文字から宣言型への対応を定義する。

静的セマンティクス

- \<single-letter\> の \<IDENTIFIER\> 要素の名前は、1 つの大文字または小文字のアルファベット（%x0041-005A または %x0061-007A）で<ins>構成されなければならない</ins>。
- \<upper-case-A\> の \<IDENTIFIER\> 要素の名称値は、"A" (%x0041) 1 文字で<ins>構成されなければならない</ins>。
- \<upper-case-Z\> の \<IDENTIFIER\> 要素の名称値は、"Z" (%x005A) 1 文字で<ins>構成されなければならない</ins>。
- \<single-letter\> からなる \<letter-spec\> は、\<single-letter\> の \<IDENTIFIER\> 要素の名称値である文字で始まるすべての \<IDENTIFIER\> トークンの、モジュール内での暗黙宣言型を定義している。

- \<letter-range\> からなる \<letter-spec\>は、\<IDENTIFIER\> トークンをもつすべてのエンティティでその名称値が最初の文字を含む \<first-letter\> \<IDENTIFIER\> 要素の名称値であり、最後の文字を含む \<last-letter\> \<IDENTIFIER\> 要素の名称値である連続する文字の範囲のいずれかの文字から始まっているもので、モジュール内での宣言型を暗黙的に定める。連続する文字の範囲とは、文字の昇順または降順の範囲であり、1 文字で構成することができる。
- \<procedural-module-declaration-section\> または \<class-module-declaration-section\> 内では、\<letter-spec\> プロダクションの間で重複が許されない。
- \<universal-letter-range\> は、モジュール内のすべての \<IDENTIFIER\> に対して単一の宣言型を暗黙的に定義する。

各 \<def-type\> に対応する宣言型は、以下の表で定義される。

| \<def-type\> | 宣言型           |
| ------------ | ---------------- |
| "DefBool"    | Boolean          |
| "DefByte"    | Byte             |
| "DefInt"     | Integer          |
| "DefLng"     | Long             |
| "DefLngLng"  | LongLong         |
| "DefLngPtr"  | LongPtr の別名   |
| "DefCur"     | Currency         |
| "DefSng"     | Single           |
| "DefDbl"     | Double           |
| "DefDate"    | Date             |
| "DefStr"     | String           |
| "DefObj"     | オブジェクト参照 |
| "DefVar"     | Variant          |

エンティティが明示的に型付けされておらず、適用可能な \<def-type\> が存在しない場合、エンティティの宣言型は `Variant` となる。

### 5.2.3 モジュール宣言部

```
common-module-declaration-element = module-variable-declaration
common-module-declaration-element =/ private-const-declaration
common-module-declaration-element =/ private-type-declaration
common-module-declaration-element =/ enum-declaration
common-module-declaration-element =/ private-external-procedure-declaration
```

どのような種類のモジュール（セクション 4.2）でも \<common-module-declaration-element\> を含むことができる。それ以外の宣言は \<procedural-module\> か \<class-module\> のどちらか一方に固有のものである。

#### 5.2.3.1 モジュール宣言の変数リスト

```
module-variable-declaration = public-variable-declaration / private-variable-declaration

global-variable-declaration = "Global"  variable-declaration-list
public-variable-declaration = "Public" ["Shared"] module-variable-declaration-list
private-variable-declaration = ("Private" / "Dim") ["Shared"] module-variable-declaration-list

module-variable-declaration-list = (withevents-variable-dcl / variable-dcl)
      *( "," (withevents-variable-dcl  / variable-dcl) )
variable-declaration-list = variable-dcl *( "," variable-dcl )
```

\<global-variable-declaration\> とオプションの `Shared` キーワード（セクション 3.3.5.1）は、他の Basic 言語の方言や VBA の古いバージョンとの構文互換性を提供する。

静的セマンティクス

- `Shared` キーワードは意味を持たない。
- 同じモジュール（セクション 4.2）に含まれる \<module-variable-declaration\> で定義された各変数（セクション 2.3）は、異なる変数名（セクション 2.3）を<ins>持たなければならない</ins>。
- \<module-variable-declaration\> 内で定義される各変数はモジュール変数であり、同じモジュール内で定義される他のモジュール変数、モジュール定数、列挙体メンバー、プロシージャ（セクション 2.4）の名前と異なる変数名を<ins>持たなければならない</ins>。
- \<global-variable-declaration\> または \<public-variable-declaration\> の一部である変数宣言は、公開変数を宣言している。この変数は、プロジェクト（セクション 4.1）内でアクセス可能である。それを包含するモジュールがクラスモジュール（セクション 4.2）、または非公開モジュール（セクション 5.2.1.4）ではないプロシージャモジュール（セクション 4.2）の場合、変数はそれを包含するプロジェクトを参照しているプロジェクト内でもアクセス可能である。
- \<private-variable-declaration\> の一部である変数宣言は、非公開変数を宣言している。その変数はそのモジュール内でのみアクセス可能である。
- \<public-variable-declaration\> で定義された変数の変数名がプロジェクト名（セクション 4.1）やモジュール名（セクション 4.2）と同じ場合、変数名へのすべての参照は \<public-variable-declaration\> を含むモジュール内で発生しない限りモジュール修飾して<ins>扱われなければならない</ins>。
- \<module-variable-declaration\> で定義された変数は、同じモジュールで定義された \<enum-declaration\> の列挙型名と同じ変数名を持つことができるが、変数名がモジュール修飾されていてもその変数名を用いて参照することはできない。
- \<public-variable-declaration\> で定義された変数が、異なるモジュールの公開されている \<enum-declaration\> の列挙型名と同じ変数名を持つ場合、その変数名への参照は \<public-variable-declaration\> を含むモジュール内で発生しない限りすべてモジュール修飾<ins>されなければらない</ins>。
- \<class-module-code-section\> の \<public-variable-declaration\> で定義された変数の宣言型（セクション 2.2）は、\<private-type-declaration\> や 非公開の列挙型名で定義された UDT（セクション 2.1）でない場合がある。
- プロシージャモジュールに含まれる \<module-variable-declaration-list\> は、\<withevents-variable-dcl\> 要素を<ins>含んではならない</ins>。

実行時セマンティクス

- \<procedural-module-declaration-section\> の要素である \<module-variable-declaration\> で定義された変数は、すべてモジュールエクステント（セクション 2.3）を持っている。
- \<class-module-declaration-section\> の要素である \<module-variable-declaration\> で定義された変数は、クラスのメンバ変数（セクション 2.5）であり、オブジェクトエクステント（セクション 2.3）を持つ。クラスの各インスタンス（セクション 2.5）は対応する個別の変数を含むことになる。

##### 5.2.3.1.1 変数宣言

```
variable-dcl = typed-variable-dcl / untyped-variable-dcl
typed-variable-dcl = TYPED-NAME [array-dim]
untyped-variable-dcl = IDENTIFIER  [array-clause / as-clause]
array-clause = array-dim [as-clause]
as-clause = as-auto-object / as-type
```

静的セマンティクス

- \<typed-variable-dcl\> は変数名（セクション 2.3）を \<TYPED-NAME\> の名称値（セクション 3.3.5.1）とする変数を定義する。
- オプションの \<array-dim\> がない場合、変数の宣言型（セクション 2.2）は \<TYPED-NAME\> の宣言型になる。
- オプションの \<array-dim\> があり、\<bounds-list\> を含まない場合、定義された変数の宣言型は、\<TYPED-NAME\> の宣言型を要素型（セクション 2.1.1）として持つ可変サイズ配列（セクション 2.2）である。
- オプションの \<array-dim\> が存在して \<bounds-list\> を含む場合、定義された変数の宣言型は固定サイズの配列（セクション 2.2）で、\<TYPED-NAME\> の宣言型が要素型となる。次元数、各次元の上限（セクション 2.1）と下限（セクション 2.1）は \<bounds-list\> で定義されたとおりとなる。
- \<untyped-variable-dcl\> に \<as-clause\> が含まれ、更にその中に \<as-auto-object\> 要素が含まれる場合、それは自動インスタンス化変数（セクション 2.5.1）を定義する。\<untyped-variable-dcl\> が \<array-dim\> 要素も含む場合、定義された配列変数の各従属変数（セクション 2.3.1）は自動インスタンス化変数となる。
- \<untyped-variable-dcl\> が \<as-clause\> を（直接または \<array-clause\> の一部としても）含まない場合、暗黙的に型付け（セクション 5.2.2）された宣言であり、その暗黙の宣言型（セクション 5.2.3.1.5）には以下の規則が適用される。
    - \<array-clause\> を含まない暗黙の型付け宣言で定義された変数の宣言型は、その暗黙の宣言型と同じである。
    - \<array-clause\> を含み、\<array-dim\> 要素に \<bounds-list\> を含まない暗黙の型付け宣言で定義された変数の宣言型は、暗黙の宣言型と同じ可変サイズ配列である。
    - \<array-clause\> の \<array-dim\> 要素に \<bounds-list\> が含まれる暗黙の型付け宣言で定義された変数の宣言型は、暗黙の宣言型と同じ固定サイズ配列となる。次元数、各次元の上限と下限は \<bounds-list\> で定義される通りとなる。
- \<untyped-variable-dcl\> に \<as-clause\> を含む \<array-clause\> がある場合、以下のルールが適用される。
    - \<array-clause\> の \<array-dim\> に \<bounds-list\> が含まれていない場合、\<as-clause\> に指定された型を持つ可変サイズ配列となる。
    - \<array-clause\> の \<array-dim\> が \<bounds-list\> を含む場合、定義された変数の宣言型は \<as-clause\> の指定した型を要素とする固定サイズ配列となる。次元数および各次元の上限と下限は \<bounds-list\> で定義される通りとなる。
    - \<as-clause\> が \<as-auto-object\> で構成されている場合、定義された変数の各従属変数は自動インスタンス化変数となる。
- \<untyped-variable-dcl\> に \<as-clause\> が含まれ、\<array-clause\> が含まれない場合、以下のルールが適用される。
    - 定義された変数の宣言型は \<as-clause\> で指定された型となる。
    - \<as-clause\> が \<as-auto-object\> で構成されている場合、定義された変数は自動インスタンス化変数となる。

##### 5.2.3.1.2 WithEvents 変数宣言

```
withevents-variable-dcl = "withevents" IDENTIFIER "as" class-type-name
 
class-type-name = defined-type-expression
```

静的セマンティクス

- \<withevents-variable-dcl\> は \<class-type-name\> 要素で指定された宣言型の変数を定義する。
- \<class-type-name\> 要素の指定型は、少なくとも 1 つのイベントメンバを持つ特定のクラスで<ins>なければならない</ins>。
- \<class-type-name\> 要素の指定型は、この宣言を含むクラスモジュールによって定義されたクラスで<ins>あってはならない</ins>。
    - \<IDENTIFIER\> にアンダースコア文字（[Unicode](./1_はじめに.md) u+005F）を付加した名称値が、この宣言を含むクラスモジュールのイベントハンドラ名の接頭辞となる。
- \<class-type-name\> の指定型は、その \<defined-type-expression\> で参照される宣言型である。

##### 5.2.3.1.3 配列の次元と境界

```
array-dim = "(" [bounds-list] ")"
bounds-list = dim-spec *("," dim-spec)
dim-spec = [lower-bound] upper-bound
lower-bound = constant-expression  "to"
upper-bound = constant-expression
Static Semantics
```

静的セマンティクス

- \<bounds-list\> を持たない \<array-dim\> は可変サイズ配列を表す。
- \<bounds-list\> は最大で 60 個の \<dim-spec\> 要素を含む。
- \<bounds-list\> を持つ \<array-dim\> は、\<bounds-list\> の \<dim-spec\> 要素数と同じ次元数の固定サイズ配列を指定する。
- \<upper-bound\> または <lower-bound\> の \<constant-expression\> は、Long 宣言型と `Let` 強制可能なデータ値として<ins>評価されなければならない</ins>。
- 次元の上限は、その次元に対応する \<dim-spec\> の \<upper-bound\> の Long データ値で指定される。
- \<lower-bound\> が存在する場合、その\<constant-expression\> には対応する次元の下限の Long データ値が指定される。
- \<lower-bound\> が存在しない場合、対応する次元の下限は、セクション 5.2.1.2 で規定されるモジュール内のデフォルトの下限値となります。
- 各次元について、下限値は上限値以下で<ins>なければならない</ins>。

##### 5.2.3.1.4 変数の型宣言

型指定は、宣言の指定型を決定する。

```
as-auto-object = "as" "new" class-type-name
as-type = "as" type-spec
type-spec = fixed-length-string-spec  / type-expression
fixed-length-string-spec = "string" "*" string-length
string-length = constant-name / INTEGER
constant-name = simple-name-expression
```

静的セマンティクス

- \<as-auto-object\> 要素の指定型は、その \<class-type-name\> 要素の指定型である。
- \<as-auto-object\> 要素の指定型は、名前付きクラスで<ins>なければならない</ins>。
- \<as-auto-object\> のインスタンス化モードは、\<as-auto-object\> 要素を含むモジュールと同じプロジェクトで定義されていない限り、PublicNotCreatable で<ins>あってはならない</ins>。

- \<as-type\> の指定型は \<type-spec\> 要素の指定型とする。
- \<type-spec\> の指定型はその構成要素の指定型となる。
- \<fixed-length-string-spec\> の指定型は String*n （n は \<string-length\> 要素のデータ値）である。
- \<type-expression\> の指定型は、\<type-expression\> が参照する宣言型となる。
- \<string-length\> の要素である \<constant-name\> は、`Long` 宣言型 と `Let` 強制可能な明示的に宣言された定数データ値を<ins>参照しなければならない</ins>。
- \<string-length\> 要素のデータ値は、その \<INTEGER\> 要素のデータ値、または \<constant-name\> が参照するデータ値で、`Long` 型に `Let` 強制可能と宣言されているものである。
- \<string-length\> 要素のデータ値は 65,526 以下で<ins>なければならない</ins>。
- \<constant-name\> の \<simple-name-expression\> 要素は、値として<ins>分類されなければならない</ins>。

##### 5.2.3.1.5 暗黙の型判定

\<type-spec\> または \<type-suffix\> によって明示的に宣言型と関連付けられていない \<IDENTIFIER\> は暗黙的に宣言型と関連付けられている場合がある。このような名前の暗黙の宣言型は次のように定義される。

- \<IDENTIFIER\> の名称値の最初の文字が \<IDENTIFIER\> を含むモジュール内の \<def-directive\> の一部である \<letter-spec\> の文字範囲にある場合、その宣言型は セクション 5.2.2 で指定されている通りである。
- それ以外の場合、宣言型は暗黙的に `Variant` となる。

#### 5.2.3.2 Const 宣言

```
public-const-declaration = ("Global" / "Public")  module-const-declaration
private-const-declaration = ["Private"] module-const-declaration
module-const-declaration = const-declaration

const-declaration = "Const"  const-item-list
const-item-list = const-item *[ "," const-item]
const-item = typed-name-const-item / untyped-name-const-item

typed-name-const-item = TYPED-NAME "=" constant-expression
untyped-name-const-item = IDENTIFIER [const-as-clause] "=" constant-expression

const-as-clause = "as" BUILTIN-TYPE
```

静的セマンティクス

- \<const-as-clause\> の \<BUILTIN-TYPE\> 要素は "object" または "[object]" であってはならない。
- 同じモジュールに含まれる \<module-const-declaration\> 内で定義された定数は、それぞれ異なる名前を<ins>持たなければならない</ins>。
- \<module-const-declaration\> 列挙型メンバー名、プロシージャ名と異なる定数名を<ins>持たなければならない</ins>。
- \<public-const-declaration\> の一部である定数宣言は公開定数の宣言となる。この定数は、宣言されたプロジェクト内からアクセス可能である。定数が宣言されたモジュールが非公開でないプロシージャモジュールの場合、そのプロジェクトを参照するプロジェクトからもアクセス可能である。
- \<private-const-declaration\> の一部である定数宣言は非公開定数の宣言となる。この定数は、宣言されたモジュール内でアクセス可能である。
- \<public-const-declaration\> で定義された定数がプロジェクト名やモジュール名と同じ名前を持つ場合、その変数名へのすべての参照は \<public-const-declaration\> を含むモジュール内で発生しない限りモジュール修飾<ins>されなければならない</ins>。
- \<module-const-declaration\> で定義された定数は、同じモジュールで定義された \<enum-declaration\> の列挙型名と同じ定数名を持つことができるが、定数名がモジュール修飾されていてもその定数名を用いて参照することはできない。
- \<public-const-declaration\> で定義された定数が別のモジュールにある公開された \<enum-declaration\> の列挙型名と同じ定数名を持つ場合、定数名へのすべての参照は \<public-const-declaration\> を含むモジュール内で発生しない限りモジュール修飾<ins>されなければならない</ins>。
- \<typed-name-const-item\> は、その名前が \<TYPED-NAME\> 要素の名称値であり、その宣言型が セクション 3.3.5.3 で規定された \<TYPED-NAME\> の \<type-suffix\> に対応する宣言型である定数を定義する。
- \<untyped-name-const-item\> は、その \<IDENTIFIER\> 要素の名称値を名前とする定数を定義する。
- \<untyped-name-const-item\> が \<const-as-clause\> を含まない場合、定数の宣言型はその \<constant-expression\> 要素の宣言型と同じとなる。そうでない場合、定数の宣言型は \<const-as-clause\> の \<BUILTIN-TYPE\> 要素の宣言型となる。
- \<const-item\> 内で使用される \<constant-expression\> は、\<constant-expression\> 内で通常許可される組み込み関数であっても、関数を参照しない場合がある。
- \<const-item\> 内の \<constant-expression\> 要素のデータ値は、その \<const-item\> によって定義された定数の宣言型と互換性が<ins>なければなりません</ins>。
- \<const-item\> によって定義される定数の定数束縛は、その定数の宣言型に `Let` 強制可能な \<constant-expression\> のデータ値である。

#### 5.2.3.3 ユーザ定義型（UDT）宣言

```
public-type-declaration = ["global" / "public"]  udt-declaration
private-type-declaration = "private" udt-declaration
udt-declaration = "type" untyped-name EOS udt-member-list EOS "end" "type"
udt-member-list = udt-element *[EOS udt-element]
udt-element = rem-statement / udt-member
udt-member = reserved-name-member-dcl / untyped-name-member-dcl
untyped-name-member-dcl = IDENTIFIER optional-array-clause
reserved-name-member-dcl = reserved-member-name as-clause
optional-array-clause = [array-dim] as-clause

reserved-member-name = statement-keyword / marker-keyword / operator-identifier / special-form / reserved-name / literal-identifier / reserved-for-implementation-use / future-reserved
```

静的セマンティクス

- \<udt-declaration\> に含まれる UDT 名は、`Type` キーワード（セクション 3.3.5.1）に続く \<untyped-name\> の名前値となる。
- 各 \<udt-declaration\>は、UDT 名で識別される一意の宣言型と一意の UDT データ型を定義する。
- \<public-const-declaration\> の一部である UDT 宣言は、公開 UDT を宣言する。 UDT はそのプロジェクト内でアクセス可能である。宣言を含むモジュールが非公開モジュールでないプロシージャモジュールである場合、UDT はそのプロジェクトを参照するプロジェクトからでもアクセス可能である。
- \<private-const-declaration\> の一部である UDT 宣言は、非公開 UDT を宣言する。UDT はそのモジュール内でアクセス可能である。
- \<udt-declaration\> が \<private-type-declaration\> の要素である場合、その UDT 名は同じモジュール内の \<enum-declaration\> や他の \<udt-declaration\> のUDT 名と同じにすることはできない。
- \<udt-declaration\> が \<public-type-declaration\> の要素である場合、その UDT 名はそれを含むプロジェクトのどのモジュール内においても、公開された \<enum-declaration\> の列挙型名または \<public-type-declaration\> の UDT 名と同一にすることはできない。
- \<udt-declaration\> が \<public-type-declaration\> の要素である場合、その UDT 名は現在の VBA 環境内のプロジェクト名やライブラリ名、\<udt-declaration\> を含むプロジェクト内のモジュール名と同じにすることはできない。
- \<reserved-member-name\> の名称値は、その予約済み識別子名のテキストである。\<udt-member-list\> の中の少なくとも 1 つの \<udt-element\> は \<udt-member\> で<ins>構成されなければならない</ins>。
- \<udt-member\> が \<untyped-name-member-dcl\> の場合、その UDT メンバ名は \<untyped-name-member-dcl\> の \<IDENTIFIER\> 要素の名称値となる。
- \<udt-member\> が \<reserved-name-member-dcl\> の場合、その UDT メンバ名は \<reserved-name-member-dcl\> の \<reserved-member-name\> 要素の名称値となる。
- \<udt-member-list\> 内の各 \<udt-member\> は、異なる UDT メンバ名を<ins>持たなければならない</ins>。
- 各 \<udt-member\> は、\<udt-declaration\> に含まれる UDT 名で識別される UDT データ型の名前付き要素を定義する。
- 各 \<udt-member\> は、\<udt-declaration\> に含まれる UDT 名で識別される UDT データ型と宣言型の名前付き要素を定義する。
- \<udt-member\> で定義される UDT 要素の宣言型は次のように定義される。
    - \<udt-member\> が \<bounds-list\> を含まない \<array-dim\> を含む場合、UDT 要素の宣言型は可変サイズ配列であり、その要素型は \<udt-member\> に含まれる \<as-clause\> である。
    - \<udt-member\> が \<bounds-list\> を含む \<array-dim\> を含む場合、UDT 要素の宣言型は固定サイズ配列であり、その要素型は \<udt-member\> に含まれる \<as-clause\> の指定型である。次元数、各次元の上限と下限は \<bounds-list\> で定義される通りである。
    - それ以外の場合、UDT 要素の宣言型は、\<as-clause\> の指定型となる。
- \<udt-member\> が \<as-clause\> を含み、それが \<as-auto-object\> で構成されている場合、宣言型が含む \<udt-declaration\> の UDT 名である任意の変数に対応する従属変数（または配列変数の各従属変数）は自動インスタンス化変数となる。

#### 5.2.3.4 列挙型宣言

```
global-enum-declaration = "global" enum-declaration 
public-enum-declaration = ["public"] enum-declaration
private-enum-declaration = "private" enum-declaration
enum-declaration = "enum" untyped-name EOS member-list EOS "end" "enum"
enum-member-list = enum-element *[EOS enum-element]
enum-element = rem-statement / enum-member
enum-member = untyped-name [ "=" constant-expression]
```

\<global-enum-declaration\> は、BASIC 言語の他の方言や VBA の歴史的なバージョンとの構文上の互換性を提供する。

静的なセマンティクス

- Enum キーワード（セクション 3.3.5.1）に続く \<untyped-name\> の名称値値は、それを含む \<enum-declaration\> の列挙型名である。
- \<global-variable-declaration\> または \<public-enum-declaration\> の一部である列挙型宣言は、公開された列挙型を宣言している。列挙型とそのメンバは、そのプロジェクト内でアクセス可能である。列挙型が宣言されたモジュールがクラスモジュールまたはプロシージャモジュールで非公開モジュールでない場合、列挙型とそのメンバはそのプロジェクトを参照するプロジェクトからでもアクセス可能である。
- \<private-enum-declaration\> の一部である列挙型宣言は、非公開の列挙型を宣言している。この列挙型とそのメンバは、そのモジュール内でアクセス可能である。
- \<private-enum-declaration\> の列挙型名は、他の \<enum-declaration\> の列挙型名や同一モジュール内の \<udt-declaration\> の UDT 名と同じにすることはできない。
- \<public-enum-declaration\> の列挙型名は、それを含むプロジェクトのどのモジュール内においても、他の公開された \<enum-declaration\> の列挙型名、または公開された \<udt-declaration\> の UDT 名と同一にすることはできない。
- \<public-enum-declaration\> の列挙型名は、現在の VBA 環境内のプロジェクトやライブラリの名前、または \<enum-declaration\> を含むプロジェクト内のモジュールと同じ名前にすることはできない。

- \<enum-member-list\> のうちの少なくとも 1 つの \<enum-element\> は \<enum-member\> で<ins>構成されなければならない\<ins>。
- \<enum-member\> の名前は、その \<untyped-name\> の名称値である。
- \<enum-member-list\> 内の各 \<enum-member\> は、それぞれ異なる列挙型メンバ名を<ins>持たなければならない</ins>。
- 列挙型のメンバ名は、同じモジュール内で定義されている変数名や定数名と同じでない場合がある。
- \<enum-member\> が \<constant-expression\> を含む場合、 \<constant-expression\> のデータ値は Long データ型に<ins>保たれなければならない</ins>。
- \<enum-member\> の \<constant-expression\> には、その \<enum-member\> の列挙型メンバ名への参照が含まれていない場合がある。
- \<enum-member\> の \<constant-expression\> には、その \<enum-member-list\> で先行する \<enum-member\> のメンバ名への参照が含まれていない可能性がある。
- \<enum-member\> の \<constant-expression\> には、\<enum-declaration\> の \<enum-member\> を含むモジュール宣言セクションで先行するすべての \<enum-member\> のメンバ名への参照が含まれていない可能性がある。
- \<enum-member\> が \<constant-expression\> を含む場合、 \<enum-member\> のデータ値は \<constant-expression\> を `Long` 型に強制したものとなる。\<enum-member\> が \<constant-expression\> を含まず、かつ \<enum-member-list\> の最初の要素である場合、そのデータ値は 0 である。\<enum-member\> が \<constant-expression\> を含まず、かつ \<enum-member-list\> の最初の要素でもない場合、そのデータ値は \<enum-member-list\> を含む前の要素より 1 大きい値である。
- \<enum-member\> の宣言型は `Long` である。
- 列挙型名（プロジェクト名で修飾されることもある）が任意の宣言の \<as-type\> 部分に表れた場合、その意味は列挙型名が宣言型 `Long` に置き換えられた場合と同じである。

#### 5.2.3.5 外部プロシージャ宣言

```
public-external-procedure-declaration = ["public"] external-proc-dcl
private-external-procedure-declaration = "private" external-proc-dcl

external-proc-dcl = "declare" ["ptrsafe"] (external-sub / external-function)

external-sub = "sub" subroutine-name lib-info [procedure-parameters]
external-function = "function" function-name lib-info  [procedure-parameters] [function-type]

lib-info = lib-clause [alias-clause]
lib-clause = "lib" STRING
alias-clause = "alias" STRING
```

静的セマンティクス

- \<public-external-procedure-declaration\> 要素と \<private-external-procedure-declaration\> 要素は外部プロシージャである。
- \<public-external-procedure-declaration\> 要素と \<private-external-procedure-declaration\> 要素はプロシージャ宣言であり、セクション 5.3.1 で定義したプロシージャ宣言の静的セマンティクスが適用される。
- \<external-sub\> 要素はサブルーチン宣言であり、\<external-function\> は関数宣言である。（訳注：逆になっていたので訂正した）
- 外部プロシージャ名が大文字と小文字を区別して解釈されるかどうかは実装定義である。
- \<alias-clause\> の \<STRING\> 要素の最初の文字が %x0023 ("#") の場合、その要素は序数エイリアスであり、文字列の残りの部分は字句トークン文法の \<integer-literal\> 規則の定義に<ins>従わなければならない</ins>。\<integer-literal\> のデータ値は 0 から 32,767 の範囲で<ins>なければならない</ins>。
- \<alias-clause\> の \<STRING\> 要素のデータ値の最初の文字が %x0023 ("#") でない場合、その \<STRING\> 要素のデータ値は実装定義された構文に<ins>従わなければならない</ins>。
- 実装は、外部プロシージャの宣言におけるパラメータ型、関数型、パラメータ機構、オプションパラメータと `ParamArray` パラメータの使用に関する制限を<ins>追加定義してもよい</ins>。
- 実装は `PtrSafe` キーワードを指定しない外部プロシージャの宣言に対する追加の制限を<ins>定義してもよい</ins>。

実行時セマンティクス

- 外部プロシージャが呼び出されたとき、その \<lib-clause\> の \<STRING\> 要素のデータ値は、VBA 言語以外の実装定義によって利用可能なプロシージャの集合を識別するために、実装定義された方法で使用される。
- 外部プロシージャが呼び出されたとき、利用可能な中からプロシージャを選択するために、そのオプションの \<alias-clause\> の \<STRING\> 要素のデータ値が実装定義された方法で使用される。\<alias-clause\> が存在しない場合、利用可能な中からプロシージャを選択するために、プロシージャ名が実装定義された方法で使用される。
- 外部プロシージャは、\<external-proc-dcl\> の \<procedure-parameters\> と \<function-type\> 要素を含む \<subroutine-declaration\> または \<function-declaration\> によって、VBA 言語で定義されたプロシージャであるかのように呼び出され引数が渡される。

#### 5.2.3.6 循環モジュールの依存関係

静的セマンティクス

- 定数宣言（セクション 5.2.3.2）、列挙型宣言（セクション 5.2.3.4）、UDT 宣言（セクション 5.2.3.3）、実装ディレクティブ（セクション 5.2.4.2）、イベント宣言（セクション 5.2.4.3）などを含むモジュール間の循環参照は許可されていない。
- これらの宣言形式のいずれかを含むモジュール間の循環的な依存関係は、依存関係の連鎖が他の形式の宣言を含んでいたとしても許可されない。
- これらの特定の宣言形式を含まないモジュール間の循環的な依存関係の連鎖は許可される。

### 5.2.4 クラスモジュール宣言

クラスモジュールは、VBA 環境内の他のモジュールから参照できる宣言型として名前付きクラスを定義する。

#### 5.2.4.1 構文外で定義されるクラス特性

クラスの特性のいくつかは、\<class-module-body\> の中では定義されず、代わりにモジュールの属性値や場合によっては実装定義される機構を使って定義される。

このクラスモジュールで定義されるクラスの名前は、クラスモジュール自体の名前である。

##### 5.2.4.1.1 クラスのアクセシビリティとインスタンス化

クラスをその名前で参照できるかどうかは、そのクラス定義のアクセシビリティによって決定される。アクセシビリティは、クラスの新しいインスタンスを作成するためにクラス名を使用する能力とは異なる。

クラスのアクセシビリティとインスタンス化の特性は、次の表で定義されるように、そのクラスモジュール宣言のモジュール属性によって決定される。

| インスタンス化モード | 意味                                                                                                                                                                                                                                                                                                                                                       | 属性値                                  |
| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------- |
| 非公開（既定）       | このクラスはそのプロジェクト内でのみアクセス可能。<br/><br/>クラスのインスタンスは、そのクラスを定義しているプロジェクトに含まれるモジュールによってのみ作成することができる。                                                                                                                                                                             | VB_Exposed=False<br/>VB_Creatable=False |
| 公開かつ作成可能     | このクラスはそのプロジェクト内及びそのプロジェクトを参照するプロジェクト内でアクセス可能。<br/><br/>クラスのインスタンスは、そのプロジェクト内のモジュールによってのみ作成することができる。他のプロジェクトのモジュールは、宣言型としてクラス名を参照することはできるが、`new` や `CreateObject` 関数を使用してクラスをインスタンス化することはできない。 | VB_Exposed=True<br/>VB_Creatable=False  |
| 公開かつ作成不可能   | このクラスは、そのプロジェクト内及びそのプロジェクトを参照するプロジェクト内でアクセス可能。<br/><br/>このクラスにアクセスできるモジュールはクラスのインスタンスを作成することができる。                                                                                                                                                                   | VB_Exposed=True<br/>VB_Creatable=True   |

実装では、ライブラリプロジェクトで定義されたクラスに適用されるインスタンス化モードを追加で定義してもよい。

##### 5.2.4.1.2 デフォルトインスタンス変数の静的セマンティクス

- クラスモジュールは `VB_PredeclaredId` 属性または `VB_GlobalNamespace` 属性が "True" の場合にデフォルトインスタンス変数を持つ。
- `VB_GlobalNamespace` 属性が "True" である場合、クラスモジュールはデフォルトインスタンス変数を持つ。このデフォルトインスタンス変数は、\<class-type-name\> がクラス名である \<as-autoobject\> 要素を含む \<module-variable-declaration\> で宣言されているかのように、モジュールエクステントで生成される。
- このクラスモジュールの `VB_PredeclaredId` 属性が "True" の場合、デフォルトインスタンス変数にはクラス名が名前として与えられる。この名前付き変数を `Set` による代入に用いることはできない。このクラスモジュールの `VB_PredeclaredId` 属性の値が "True" でない場合、デフォルトインスタンス変数は公開される名前を持たない。
- `VB_GlobalNamespace` 属性が "True" の場合、クラスモジュールはグローバルクラスモジュールとみなされ、セクション 5.6.10 に規定されるデフォルトインスタンスのメンバへの単純な名前アクセスが許可される。
- `VB_PredeclaredId` 属性と `VB_GlobalNamespace` 属性の両方が "True" の場合、両方の属性のセマンティクスによって同じデフォルトインスタンス変数が共有されることに注意すること。

##### 5.2.4.2 実装ディレクティブ

```
implements-directive = "Implements" class-type-name
```

静的セマンティクス

- \<implements-directive\> は、拡張モジュール内では使用できない。
- \<class-type-name\> で指定されたクラスはインターフェースクラスと呼ばれる。
- インターフェースクラスは、\<implements-directive\> を含むクラスモジュールで定義されたクラスである必要はない。
- 同じクラスモジュール内の複数の \<implements-directive\> で、特定のクラスをインターフェースクラスとして指定することはできない。
- 同じクラスモジュールに含まれる全てのインターフェースクラスの非修飾クラス名は、互いに<ins>異なるものでなければらない</ins>。
- インターフェースクラスのクラス名にアンダースコア文字（[Unicode](./1_はじめに.md) u+005F）を付加したものが、 このディレクティブを含むクラスモジュール内の実装インターフェース名の接頭辞となる。
- クラスモジュールが複数の \<implements-directive\> を含んでいる場合、その実装インターフェース名の接頭辞のすべてにおいて、他の実装名プレフィックスの頭文字とすることはできない。
- クラスが持つ公開変数やメソッドの名前にアンダースコア文字（Unicode u+005F）が含まれている場合、そのクラスはインターフェースクラスとして使用することはできない。
- \<implements-directive\> を含むクラスモジュールは、 インターフェースクラスのクラスモジュールに含まれる公開メソッドの宣言に対応する実装名の宣言を<ins>含まなければならない</ins>。
- \<implements-directive\> を含むクラスモジュールは、 インターフェースのクラスモジュールに含まれる公開変数宣言に対応する実装名宣言を<ins>含まなければならない</ins>。必要な実装名宣言は、以下のように宣言された公開変数の型に依存する。
    - 宣言された変数の型が `Variant` の場合、\<property-get-declaration\> と \<property-lhs-declaration\> を含む 3 つの対応する実装名の宣言が<ins>なければならない</ins>。
    - 宣言された変数の型が `Object` または名前付きクラスの場合、\<property-get-declaration\> と \<property-lhs-declaration\> を含む 2 つの対応する実装名の宣言が<ins>なければならない</ins>。
    - 宣言された変数の型がそれ以外の場合、\<property-get-declaration\> と \<property-lhs-declaration\> の 2 つの対応する実装名の宣言が<ins>なければならない</ins>。


#### 5.2.4.3 イベント宣言

```
event-declaration = ["Public"]
"Event" IDENTIFIER [event-parameter-list]
event-parameter-list = "(" [positional-parameters] ")"
```

静的セマンティクス

- \<event-declaration\> は、そのクラスモジュールが定義するクラスのイベントメンバを定義する。
- `Public` キーワード（セクション 3.3.5.1）で始まらない \<event-declaration\> は、`Public` が存在する場合と同じ意味をもつ。
- イベントメンバのイベント名は、\<IDENTIFIER\> の名称値とする。
- クラスモジュール宣言セクション内の各 \<event-declaration\> は、異なるイベント名を<ins>指定しなければならない</ins>。
- イベント名は、同じモジュール内で定義されているモジュール変数名、モジュール定数名、列挙型メンバ名、プロシージャ名と同じ名称値を持つことができる。
- イベント名は、アンダースコア文字（[Unicode](./1_はじめに.md) u+005F）を<ins>含んではならない</ins>。

実行時セマンティクス

- \<event-parameter-list\> に含まれる \<positional-param\> 要素は、いかなる変数や変数束縛も定義しない。それらは単に、関連付けられたイベント名を参照する \<raiseevent-statement\> に提供されなければならない引数を記述するだけである。

## 5.3 モジュールのコード部の構造

```
procedural-module-code-section = *( LINE-START  procedural-module-code-element LINE-END)
class-module-code-section = *( LINE-START  class-module-code-element LINE-END)

procedural-module-code-element = common-module-code-element
class-module-code-element = common-module-code-element / implements-directive

common-module-code-element = rem-statement / procedure-declaration

procedure-declaration = subroutine-declaration / function-declaration /        property-get-declaration / property-LHS-declaration
```

VBA 言語では、プロシージャを定義するためにいくつかの構文形式が使用されている。この仕様のいくつかの文脈では、様々な種類の宣言を参照する必要がある。次の表は、この仕様で使用される宣言の種類と、どの文法生成を使用するかを定義している。セルにチェックマークが表示されている場合、その列で定義されている宣言の種類は、その行の文法生成で定義されている宣言を参照することができる。

| 文法ルール                   | プロシージャ宣言 | メソッド宣言 | プロパティ宣言 | サブルーチン宣言 | 関数宣言 |
| ---------------------------- | :--------------: | :----------: | :------------: | :--------------: | :------: |
| \<subroutine-declaration\>   | ✓                | ✓            |                | ✓                |          |
| \<function-declaration\>     | ✓                | ✓            |                |                  | ✓        |
| \<external-sub\>             | ✓                |              |                | ✓                |          |
| \<external-function\>        | ✓                |              |                |                  | ✓        |
| \<property-get-declaration\> | ✓                | ✓            | ✓              |                  | ✓        |
| \<property-lhs-declaration\> | ✓                | ✓            | ✓              | ✓                |          |

### 5.3.1 プロシージャ宣言

```
subroutine-declaration = procedure-scope [initial-static]
               "sub" subroutine-name [procedure-parameters] [trailing-static] EOS
                        [procedure-body EOS]
               [end-label] "end" "sub" procedure-tail

function-declaration = procedure-scope [initial-static]
                        "function" function-name [procedure-parameters] [function-type] [trailing-static] EOS
                 [procedure-body EOS]
                  [end-label]  "end" "function" procedure-tail

property-get-declaration = procedure-scope [initial-static]
                 "Property" "Get"
                 function-name [procedure-parameters] [function-type] [trailing-static] EOS
                           [procedure-body EOS]
                           [end-label] "end" "property" procedure-tail

property-lhs-declaration = procedure-scope [initial-static]
                 "Property" ("Let" / "Set")
                  subroutine-name property-parameters [trailing-static] EOS
              [procedure-body EOS]
                 [end-label] "end" "property" procedure-tail

end-label = statement-label-definition
procedure-tail = [WS] LINE-END / single-quote comment-body /  ":" rem-statement
```

静的セマンティクス

- 関数宣言は関数結果変数と呼ばれるローカル変数を暗黙的に定義する。この変数名と宣言型は関数と共有されスコープは関数本体となる。
- 関数宣言はその名前がその \<function-name\> の名称値であるプロシージャを定義し、サブルーチン宣言はその名前がその \<subroutine-name\> の名称値であるプロシージャを定義する。
- 関数宣言の \<function-name\> 要素が \<TYPED-NAME\> の場合、関数宣言に \<function-type\> 要素が含まれていない可能性がある。
- 関数宣言の宣言型は次のように定義される。
    - 関数宣言の \<function-name\> 要素が \<TYPED-NAME\> である場合、関数宣言の宣言型はセクション 3.3.5.3 で指定されている \<TYPED-NAME\> の \<type-suffix\> に対応する宣言型である。
    - 関数宣言の \<function-name\> 要素が \<TYPED-NAME\> ではなく、関数宣言に \<function-type\> 要素が含まれていない場合、宣言型は、セクション 5.2.3.1.5 で指定されている暗黙型である。
    - 関数宣言に \<function-type\> 要素が含まれる場合、関数宣言の宣言型は \<function-type\> 要素の指定型である。
- \<class-module-code-section\> の一部である関数宣言の宣言型は、\<private-type-declaration\> によって定義された UDT ではない可能性がある。
- 関数宣言の宣言型は、非公開列挙名ではない可能性がある。
- オプションの \<end-label\> が存在する場合、その \<statement-label\> には \<procedure-body\> 内で定義された \<statement-label\> とは異なるラベル値が含まれている必要がある。

実行時セマンティクス

- プロシージャに含まれるコードはプロシージャの呼び出し中に実行される。
- プロシージャの各呼び出しには、プロシージャ内の各 `ByVal` パラメータ、またはプロシージャエクステント変数宣言に対応する個別の変数がある。
- 関数宣言の各呼び出しには、個別の関数結果変数がある。
- 関数結果変数にはプロシージャエクステントがある。
- \<class-module-code-section\> 内で定義されたプロシージャ宣言の \<procedure-body\> 内での予約名 `Me` の宣言型は、そのクラスモジュールによって定義された名前付きクラスであり、"me" のデータ値は関数の現在アクティブな呼び出しの対象オブジェクトへのオブジェクト参照である。
- プロシージャの呼び出しは次の手順で構成される。
    1. `ByVal` パラメータに対応するプロシージャエクステント変数を作成する。
    2. セクション 5.3.1.11 で定義されているように実引数を処理する。
    3. プロシージャのエラー処理ポリシー（セクション 5.4.4）をデフォルトポリシーに設定する。
    4. 関数結果変数と、プロシージャ内で宣言されたプロシージャエクステントのローカル変数を作成する。
    5. \<procedure-body\> を実行する。
    6. プロシージャが関数の場合、関数結果変数のデータ値を関数の結果として呼び出し側に返す。
    7. 呼び出しが完了し、呼び出し側で実行が継続される。

#### 5.3.1.1 プロシージャスコープ

procedure-scope = ["global" / "public" / "private" / "friend"]

静的セマンティクス

- <procedure-declaration> に <procedure-scope> 要素を含まないものは、Public キーワード（セクション 3.3.5. 1）からなる <procedure-scope> 要素を含む場合と同じ意味を持つ。
- Public キーワード または Global キーワードからなる <procedure-scope> 要素を含む <procedure-declaration> は、公開プロシージャを宣言している。このプロシージャはそのプロジェクト内でアクセス可能である。そのモジュールがクラスモジュールまたは非公開モジュールでないプロシージャモジュールである場合、そのプロシージャはそのプロジェクトを参照するプロジェクト内でもアクセス可能である。
- Friend キーワードからなる <procedure-scope> 要素を含む <procedure-declaration> は、フレンドプロシージャを宣言している。このプロシージャはそのプロジェクト内でアクセス可能である。
- Private キーワードからなる <procedure-scope> 要素を含む <procedure-declaration> は、非公開プロシージャを宣言する。このプロシージャは、そのモジュール内でアクセス可能である。
- Global キーワードからなる <procedure-scope> は <class-module-code-section> に含まれる <procedure-declaration> の要素でない場合がある。
- Friend キーワードで構成される <procedure-scope> は、<procedural-module-code-section> に含まれる <procedure-declaration> の要素にならない場合がある。

#### 5.3.1.2 静的プロシージャ

initial-static = "static"
trailing-static = "static"

静的セマンティクス

- <initial-static> 要素または <trailing-static> 要素を含む <procedure-declaration> は、静的プロシージャを宣言している。
- <procedure-declaration> に <initial-static> 要素と <trailing-static> 要素の両方が含まれることはない。

実行時セマンティクス

- 静的プロシージャの <procedure-body> 内で宣言されたすべての変数は、モジュールエクステントを持つ。
- 非静的プロシージャの <procedure-body> 内で宣言されたすべての変数は、プロシージャエクステントを持つ。

#### 5.3.1.3 プロシージャ名

subroutine-name = IDENTIFIER / prefixed-name
function-name = TYPED-NAME / subroutine-name
prefixed-name = event-handler-name / implemented-name / lifecycle-handler-name

静的セマンティクス

- プロシージャ宣言内のプロシージャ名は、それが含まれる <subroutine-name> または <function-name> 要素の名称値である。
- 公開された可視性であるプロシージャ宣言が、プロジェクト名またはモジュール名と同じプロシージャ名をもつ場合、そのプロシージャを定義するモジュール内で参照が発生しない限りプロシージャ名へのすべての参照はそのプロジェクト名またはモジュール名で明示的に<ins>修飾されなければならない</ins>。

#### 5.3.1.4 関数の型宣言

function-type = "as" type-expression [array-designator]
array-designator = "(" ")"

静的セマンティクス

- <array-designator> 要素を含まない <function-type> の指定型は、その <type-expression> 要素で参照される宣言型となる。
- <array-designator> 要素を含む <function-type> の指定型は、<type-expression> 要素で参照される宣言型を持つ可変サイズ配列となる。

#### 5.3.1.5 仮引数リスト

procedure-parameters = "(" [parameter-list] ")"
property-parameters = "(" [parameter-list ","] value-param ")"

parameter-list = (positional-parameters "," optional-parameters ) /
                  (positional-parameters  ["," param-array]) /
                  optional-parameters /
                  param-array

positional-parameters = positional-param *("," positional-param)
optional-parameters = optional-param *("," optional-param)
value-param = positional-param
positional-param = [parameter-mechanism] param-dcl
optional-param = optional-prefix param-dcl [default-value]
param-array = "paramarray" IDENTIFIER "(" ")" ["as" ("variant" / "[variant]")]

param-dcl = untyped-name-param-dcl / typed-name-param-dcl
untyped-name-param-dcl = IDENTIFIER [parameter-type]
typed-name-param-dcl = TYPED-NAME [array-designator]
optional-prefix = ("optional" [parameter-mechanism]) / ([parameter-mechanism] ("optional"))
parameter-mechanism = "byval" / " byref"
parameter-type = [array-designator] "as" (type-expression / "Any")
default-value = "=" constant-expression

静的セマンティクス

#### 5.3.1.1 プロシージャスコープ

```
procedure-scope = ["global" / "public" / "private" / "friend"]
```

静的セマンティクス

- \<procedure-declaration\> に \<procedure-scope\> 要素を含まないものは、Public キーワード（セクション 3.3.5. 1）からなる \<procedure-scope\> 要素を含む場合と同じ意味を持つ。
- `Public` キーワード または `Global` キーワードからなる \<procedure-scope\> 要素を含む \<procedure-declaration\> は、公開プロシージャを宣言している。このプロシージャはそのプロジェクト内でアクセス可能である。そのモジュールがクラスモジュールまたは非公開モジュールでないプロシージャモジュールである場合、そのプロシージャはそのプロジェクトを参照するプロジェクト内でもアクセス可能である。
- `Friend` キーワードからなる \<procedure-scope\> 要素を含む \<procedure-declaration\> は、フレンドプロシージャを宣言している。このプロシージャはそのプロジェクト内でアクセス可能である。
- `Private` キーワードからなる \<procedure-scope\> 要素を含む \<procedure-declaration\> は、非公開プロシージャを宣言する。このプロシージャは、そのモジュール内でアクセス可能である。
- `Global` キーワードからなる \<procedure-scope\> は \<class-module-code-section\> に含まれる \<procedure-declaration\> の要素でない場合がある。
- `Friend` キーワードで構成される \<procedure-scope\> は、\<procedural-module-code-section\> に含まれる \<procedure-declaration\> の要素にならない場合がある。

#### 5.3.1.2 静的プロシージャ

```
initial-static = "static"
trailing-static = "static"
```

静的セマンティクス

- \<initial-static\> 要素または \<trailing-static\> 要素を含む \<procedure-declaration\> は、静的プロシージャを宣言している。
- \<procedure-declaration\> に \<initial-static\> 要素と \<trailing-static\> 要素の両方が含まれることはない。

実行時セマンティクス

- 静的プロシージャの \<procedure-body\> 内で宣言されたすべての変数は、モジュールエクステントを持つ。
- 非静的プロシージャの \<procedure-body\> 内で宣言されたすべての変数は、プロシージャエクステントを持つ。

#### 5.3.1.3 プロシージャ名

```
subroutine-name = IDENTIFIER / prefixed-name
function-name = TYPED-NAME / subroutine-name
prefixed-name = event-handler-name / implemented-name / lifecycle-handler-name
```

静的セマンティクス

- プロシージャ宣言内のプロシージャ名は、それが含まれる \<subroutine-name\> または \<function-name\> 要素の名称値である。
- 公開された可視性であるプロシージャ宣言が、プロジェクト名またはモジュール名と同じプロシージャ名をもつ場合、そのプロシージャを定義するモジュール内で参照が発生しない限りプロシージャ名へのすべての参照はそのプロジェクト名またはモジュール名で明示的に<ins>修飾されなければならない</ins>。

#### 5.3.1.4 関数の型宣言

```
function-type = "as" type-expression [array-designator]
array-designator = "(" ")"
```

静的セマンティクス

- \<array-designator\> 要素を含まない \<function-type\> の指定型は、その \<type-expression\> 要素で参照される宣言型となる。
- \<array-designator\> 要素を含む \<function-type\> の指定型は、\<type-expression\> 要素で参照される宣言型を持つ可変サイズ配列となる。

#### 5.3.1.5 仮引数リスト

```
procedure-parameters = "(" [parameter-list] ")"
property-parameters = "(" [parameter-list ","] value-param ")"

parameter-list = (positional-parameters "," optional-parameters ) /
                 (positional-parameters  ["," param-array]) /
                 optional-parameters /
                 param-array

positional-parameters = positional-param *("," positional-param)
optional-parameters = optional-param *("," optional-param)
value-param = positional-param
positional-param = [parameter-mechanism] param-dcl
optional-param = optional-prefix param-dcl [default-value]
param-array = "paramarray" IDENTIFIER "(" ")" ["as" ("variant" / "[variant]")]

param-dcl = untyped-name-param-dcl / typed-name-param-dcl
untyped-name-param-dcl = IDENTIFIER [parameter-type]
typed-name-param-dcl = TYPED-NAME [array-designator]
optional-prefix = ("optional" [parameter-mechanism]) / ([parameter-mechanism] ("optional"))
parameter-mechanism = "byval" / " byref"
parameter-type = [array-designator] "as" (type-expression / "Any")
default-value = "=" constant-expression
```

静的セマンティクス

- \<parameter-type\> 要素は、\<external-proc-dcl\> の一部である場合にのみキーワード `Any` を含める。
- \<typed-name-param-dcl\> の名前は \<TYPED-NAME\> 要素の名前になる。
- \<untyped-name-param-dcl\> の名称値は \<IDENTIFIER\> 要素の名称値です。
- \<param-dcl\> の名前は構成要素である \<untyped-name-param-dcl\> または \<typed-name-param-dcl\> の名前になる。
- \<positional-param\> 要素や \<optional-param\> 要素の名前は、その \<param-dcl\> 要素の名前である。
- \<param-array\> 要素の名前は \<IDENTIFIER\> 要素の名前になる。
- 同じ \<parameter-list\>, \<property-parameters\>, \<event-parameter-list\> の要素である \<positional-param\>, \<optional-param\>, \<param-array\> はそれぞれ個別の名前を<ins>持たなければならない</ins>。
- 関数宣言の要素である \<positional-param\>, \<optional-param\>, \<param-array\> の名前は、関数宣言の名前と<ins>異なっていなければならない</ins>。
- \<positional-param\>, \<optional-param\>, \<param-array\> の名前は、\<procedure-body\> 内の \<local-variable-declaration\>, \<static-variable-declaration\>, \<redim-statement\>, \<local-const-declaration\> で定義した変数名とは異なる可能性がある。
- \<positional-param\>, \<optional-param\>, \<value-param\> の宣言型は、その構成要素の \<param-dcl\> の宣言型となる。
- \<untyped-name-param-dcl\> からなる \<param-dcl\> の宣言型は以下のように定義される。
    - オプションの \<parameter-type\> 要素が存在しない場合、宣言型は セクション 5.2.3.1.5 で規定される \<IDENTIFIER\> の暗黙型となる。
    - 指定されたオプションの \<parameter-type\> 要素が存在するが \<array-designator\> 要素を含まない場合、宣言型はその \<type-expression\> 要素で参照される宣言型となる。
    - オプションの \<parameter-type\> 要素があり \<array-designator\> 要素を含む場合、宣言型は \<type-expression\> 要素が参照する宣言型を要素とする可変サイズ配列になる。
- \<typed-name-param-dcl\> からなる \<param-dcl\> の宣言型は次のように定義される。
    - オプションの \<array-designator\> 要素が存在しない場合、セクション 3.3.5.3 で規定される \<TYPED-NAME\> の \<type-suffix\> に対応する宣言型となります。
    - オプションの \<array-designator\> 要素が存在する場合、定義された変数の宣言型は、セクション 3.3.5.3 で指定された \<TYPED-NAME\> の \<type-suffix\> に対応する要素の宣言型で可変サイズ配列になる。
- \<class-module-code-section\> 内のイベント宣言や公開プロシージャ宣言に含まれる \<param-dcl\> の宣言型は、非公開 UDT、プロシージャモジュールで定義された公開 UDT、非公開列挙型名でない可能性がある。
- \<optional-param\> の宣言型は UDT でない可能性がある。
- \<optional-param\> の宣言型が `Variant` でなく、適用可能な \<def-directive\> によって暗黙的に型が指定された場合、\<default-value\> が<ins>指定されなければならない</ins>。
- \<default-value\> は引数のデフォルト値を指定する。`Variant` 引数に \<default-value\> が指定されない場合、デフォルト値は標準エラーコード 448（名前付き引数が見つからない）に解決される実装定義のエラー値となる。`Variant` でない引数に \<default-value\> が指定されない場合、デフォルト値はその引数の宣言型となる。
- \<positional-param\> または \<optional-param\> 要素に \<parameter-mechanism\> 要素を含まないものは、キーワード `ByRef` からなる \<parameter-mechanism\> 要素を含む場合と同じ意味を持つ。
- キーワード `ByVal` からなる \<parameter-mechanism\> 要素を含む \<param-dcl\> は、\<array-designator\> 要素を含まないかもしれない。
- \<param-array\> の \<IDENTIFIER\> の宣言型は `Variant` の可変サイズ配列である。

実行時セマンティクス

- 関数の各呼び出しは個別の関数結果変数を持つ。
- 関数結果変数はプロシージャーエクステントを持つ。
- キーワード `ByVal` からなる \<parameter-mechanism\> 要素を含む各 \<positional-param\> または \<optional-param\> はプロシージャエクステントを持ち、その宣言型が構成要素の \<param-dcl\> 要素の宣言型となるローカル変数を定義する。対応するパラメータ名はそのローカル変数に束縛される。
- キーワード `ByVal` からなる \<parameter-mechanism\> 要素を含む各 \<positional-param\> は、対応する位置引数に対応する既存変数へのローカル名の束縛を定義する．
- キーワード `ByRefP からなる \<parameter-mechanism\> 要素を含む各 \<optional-param\> は、構成要素 \<param-dcl\> の宣言型であり、プロシージャエクステントを持つローカル変数を定義する。
    - もしこのプロシージャの呼び出しに \<optional-param\> に対応する引数が含まれていなければ、引数名はその呼び出しのためのローカル変数に束縛される。
    - \<optional-param\> に対応する引数が含まれる場合、引数名はその引数に対応する既存変数に局所的に束縛される。
- プロシージャを呼び出すと、対応する引数を持たない各 \<optional-param\> の構成要素である \<default-value\> のデータ値が、その \<optional-param\> の引数名の変数束縛に割り当てられる。
- メソッドである各プロシージャには、メソッドの呼び出しの対象オブジェクトに対応するカレントオブジェクトと呼ばれる暗黙の `ByVal` 引数が存在する。カレントオブジェクトは、プロシージャエクステントを持つ匿名ローカル変数として機能し、その宣言型はメソッド宣言を含むクラスモジュールのクラス名である。メソッドがアクティブである間、現在のオブジェクト変数のデータ値はそのプロシージャ呼び出しの対象オブジェクトとなる。カレントオブジェクトは、メソッドの \<procedure-body\> 内で `Me` キーワードを使用してアクセスされるが、割り当てられたり変更されたりすることはない。
- プロシージャの \<parameter-list\> に \<param-array\> 要素がある場合、プロシージャの各呼び出しは引数配列という実体を定義し、それがあたかも `Variant` 宣言型の要素を持つ "ByRef" \<positional-param\> 配列であるかのように動作する。引数配列の要素へのアクセスは、あたかも名前付き位置引数へのアクセスのように振る舞う。引数はセクション 5.3.1.11 に定義されるように 引数配列の要素に束縛される。

#### 5.3.1.6 サブルーチンと関数の宣言

静的セマンティクス

- 各 \<subroutine-declaration\> と \<function-declaration\> は、同じモジュール内で定義されている他のモジュール変数名、モジュール定数名、列挙型メンバ名、プロシージャ名とは異なるプロシージャ名を<ins>持たなければならない</ins>。

#### 5.3.1.7 プロパティ宣言

静的セマンティクス

- キーワード `Let` を含む \<property-LHS-declaration\> は、Let プロパティ宣言である。
- キーワード `Set` を含む \<property-LHS-declaration\> は Set プロパティ宣言である。
- 各プロパティ宣言は、同じモジュール内で定義された他のモジュール変数、モジュール定数、列挙型メンバ名、外部プロシージャ、\<function-declaration\>、\<subroutine-declaration\> の名前と異なるプロシージャ名を<ins>持たなければならない</ins>。
- モジュール内の各 \<property-get-declaration\> は異なる名前を<ins>持たなければならない</ins>。
- モジュール内の各 Let プロパティ宣言は異なる名前を<ins>持たなければならない</ins>。
- モジュール内の各 Set プロパティ宣言は異なる名前を<ins>持たなければならない</ins>。
- モジュール内では、\<property-get-declaration\>、Let プロパティ宣言、Set プロパティ宣言でプロシージャ名を共有することができる。

- モジュール内でプロシージャ名を共有するすべてのプロパティ宣言は、\<positional-parameters\>, \<optional-parameters\>, \<param-array\> 要素の数、対応する引数の名称値、対応する引数の宣言型、対応する引数に実際に使用する \<parameter-mechanism\> が、等しい \<parameter-list\> 要素で<ins>なければならない</ins>。しかし、対応する \<optional-param\> 要素は、その \<default-value\> 要素の存在とデータ値が異なることがあり、\<parameter-mechanism\> が暗黙的か明示的のどちらに指定されているかも異なることがある。

- \<property-LHS-declaration\> の宣言型は、その \<value-param\> 要素の宣言型である。
- Set プロパティ宣言の宣言型は、`Object` 、 `Variant` 、名前付きクラスで<ins>なければならない</ins>。
- モジュール内では、共通のプロシージャ名を持つ Let プロパティ宣言と \<property-get-declaration\> は同じ宣言型を<ins>持たなければならない</ins>。
- \<property-LHS-declaration\> の \<value-param\> に \<parameter-mechanism\> 要素がないか、キーワード `ByRef` からなる \<parameter-mechanism\> 要素がある場合、代わりにキーワード `ByVal` からなる \<parameter-mechanism\> 要素があるのと同じ意味を持つ。

実行時セマンティクス

- \<property-LHS-declaration\> の \<value-param\> は常に `ByVal` 引数の実行時セマンティクスを持つ。
- \<property-LHS-declaration\> に \<param-array\> 要素が含まれる場合、そのプロパティを呼び出す際に \<value-param\> に対応する引数は、引数配列の要素に含まれない。
