# 5 モジュール本体

モジュール本体（セクション 4.2）には、本仕様で定義する VBA プログラミング言語の構文で記述されたソースコードが含まれる。本章では、モジュール本体の有効な構文、静的セマンティクス、実行時セマンティクスを定義する。

構文は、セクション 3 で定義された終端記号を組み込んだ ABNF [[RFC4234]](https://go.microsoft.com/fwlink/?LinkId=90462) 文法を用いて記述される。\<LINE-START\> と \<LINE-END\> 要素を明示的に識別する場合を除き、この文法はモジュール本体のソースコードを含むファイルの物理的な行構造を無視する。この文法は、セクション 3.4 で説明するように、条件付きコンパイル指示文と条件付き除外ソースコードも無視する。この文法は前処理されたモジュール本体（セクション 3.4）に適用され、ソースコードは字句トークン化と条件付きコンパイルの両方の前処理が適用されたかのように解釈される。この前処理は本仕様を単純化し明確にするためにのみなされる。実装が実際にこのような処理モデルを使用する必要はない。

## 5.1 モジュール本体の構造

```
procedural-module-body = LINE-START  procedural-module-declaration-section
                         LINE-START  procedural-module-code-section

class-module-body = LINE-START  class-module-declaration-section
                    LINE-START  class-module-code-section
```

プロシージャモジュール（セクション 4.2）とクラスモジュール（セクション 4.2）はともに、宣言部（セクション 5.2）とコード部（セクション 5.3）の二つの部分からなるモジュール本体（セクション 4.2）を持っている。各部分は、それを含むソースファイルの物理的な行の最初の構文要素として<ins>出現しなければならない</ins>。

本仕様では、様々な形式のエンティティ（セクション 2.2）名を表現するために以下の共通文法規則を使用する。

```
unrestricted-name = name / reserved-identifier
name = untyped-name / TYPED-NAME
untyped-name = IDENTIFIER / FOREIGN-NAME
```

## 5.2 モジュール宣言部の構造

モジュール（セクション 4.2）の宣言部は、ディレクティブと宣言から構成される。一般的に、ディレクティブはモジュール内の静的セマンティクスの適用を制御する。宣言はプログラムの実行環境内に存在する名前付きエンティティを定義する。

```
procedural-module-declaration-section = [*(procedural-module-directive-element EOS) def-directive]  *( procedural-module-declaration-element EOS)
class-module-declaration-section = [*(class-module-directive-element EOS) def-directive]  *(class-module-declaration-element EOS)
procedural-module-directive-element = common-option-directive / option-private-directive / def-directive 
procedural-module-declaration-element = common-module-declaration-element / global-variable-declaration / public-const-declaration / public-type-declaration / public-external-procedure-declaration / global-enum-declaration / common-option-directive / option-private-directive

class-module-directive-element = common-option-directive / def-directive / implements-directive
class-module-declaration-element = common-module-declaration-element / event-declaration / commonoption-directive / implements-directive 
```

静的セマンティクス

モジュール宣言部の中でのディレクティブと宣言の出現回数と相対的な順序には様々な制限がある。これらの制限は、個々のディレクティブと宣言の要素の定義の一部として指定される。

### 5.2.1 Option ディレクティブ

`Option` ディレクティブは、様々な言語機能の代替セマンティクスを選択するために使用される。

```
common-option-directive = option-compare-directive /  option-base-directive / option-explicit-directive  / rem-statement
```

静的セマンティクス

- 各 \<common-option-directive\> は、各 \<procedural-module-declaration-section\> または \<class-module-declaration-section\> に最大 1 回まで出現することが可能である。
- \<option-private-directive\> は、各 \<procedural-module-declaration-section\> に最大 1 回まで出現することが可能である。

#### 5.2.1.1 Option Compare ディレクティブ

`Option Compare` ディレクティブは、関係演算子（セクション 5.6.9.5）がモジュール（セクション 4.2）内の文字列データ値（セクション 2.1）に適用される際の比較規則を決定する。これはモジュールの比較モードとして知られている。

```
option-compare-directive = "Option"   "Compare"   ( "Binary" / "Text")
```

静的セマンティクス

- \<option-compare-directive\> が `Binary` キーワード（セクション 3.3.5.1）を含んでいる場合、モジュールの比較モードはバイナリ比較モードになる。
- \<option-compare-directive\> が `Text` キーワードを含んでいる場合、モジュールの比較モードはテキスト比較モードになる。
- \<option-compare-directive\> は \<procedural-module-declaration-section\> や \<class-module-declaration-section\> 内に 1 つだけ存在できる。
- \<procedural-module-declaration-section\> または \<class-module-declaration-section\> が \<option-compare-directive\> を含んでいない場合、そのモジュールの比較モードはバイナリ比較モードとなる。

#### 5.2.1.2 Option Base ディレクティブ

`Option Base` ディレクティブは、モジュール（セクション 4.2）で使用する、\<dim-spec\> の \<lower-bound\> で明示的に指定されていないすべての配列次元の下限（セクション 2.1）にデフォルト値を設定する。

```
option-base-directive = "Option"   "Base"     INTEGER
```

静的セマンティクス

- \<option-base-directive\> は \<procedural-module-declaration-section\> や \<class-module-declaration-section\> 内に最大 1 回まで出現することが可能である。
- もし、\<option-base-directive\> があるならば、同じ \<procedural-module-declaration-section\> や \<class-module-declaration-section\> 内で最初に現れる \<dim-spec\> の前に<ins>なければならない</ins>。
- \<INTEGER\> のデータ値（セクション 2.1）は、整数データ値 0 または 1 のどちらかに<ins>等しくなければならない</ins>。
- それを含むモジュールにおける配列次元のデフォルトの下限値は \<INTEGER\> 要素のデータ値となる。
- \<procedural-module-declaration-section\> や \<class-module-declaration-section\> に \<option-base-directive\> がない場合、モジュール内の配列次元の下限のデフォルト値は 0 となる。

#### 5.2.1.3 Option Explicit ディレクティブ

`Option Explicit` ディレクティブは、変数（セクション 2.3）を包含するモジュール（セクション 4.2）内で暗黙的に宣言（セクション 5.6.10）できるかどうかを制御する変数宣言モードを設定するために使用される。

```
option-explicit-directive = "Option"   "Explicit"
```

静的セマンティクス

- モジュール内に \<option-explicit-directive\> が存在する場合、そのモジュールの変数宣言モードは明示的モードとなる。
- \<option-explicit-directive\> がモジュール内に存在しない場合、モジュールの変数宣言モードは暗黙的モードとなる。
- \<option-explicit-directive\> は \<procedural-module-declaration-section\> または \<class-module-declaration-section\> の中に 1 つだけ存在することが可能である。
- \<procedural-module-declaration-section\> または \<class-module-declaration-section\> に \<option-explicit-directive\> がない場合、そのモジュールの変数宣言モードは暗黙的モードとなる。

#### 5.2.1.4 Option Private ディレクティブ

`Option Private` ディレクティブは、モジュール（セクション 4.2）の他のプロジェクト（セクション 4.1）に対するアクセス制限を制御し、モジュール内で宣言された `Public` エンティティ（セクション 2.2）の公開アクセスの意味も制御する。

```
option-private-directive = "Option"   "Private"   "Module"
```

静的セマンティクス

- プロシージャモジュール（セクション 4.2）に \<option-private-directive\> が含まれている場合、そのモジュール自身は非公開モジュールとみなされ、そのプロジェクト内でのみアクセス可能である。
- プロシージャモジュールに \<option-private-directive\> が含まれていない場合、そのモジュール自体は公開モジュールとみなされ、そのプロジェクト内およびそのプロジェクトを参照しているすべてのプロジェクト内でアクセス可能である。
- モジュールのアクセス制限がモジュール内の宣言のアクセス制限に及ぼす影響については、セクション 5.2.3 の特定のモジュール宣言形式の定義で説明されている。


### 5.2.2 暗黙定義ディレクティブ
```
def-directive = def-type  letter-spec *( "," letter-spec)
letter-spec = single-letter /  universal-letter-range / letter-range

single-letter = IDENTIFIER   ; %x0041-005A / %x0061-007A

universal-letter-range = upper-case-A "-"upper-case-Z
upper-case-A = IDENTIFIER
upper-case-Z = IDENTIFIER

letter-range = first-letter  "-" last-letter
first-letter = IDENTIFIER
last-letter = IDENTIFIER

def-type = "DefBool" / "DefByte" / "DefCur" /  "DefDate" / "DefDbl" / "DefInt" / "DefLng" / "DefLngLng" / "DefLngPtr" / "DefObj" / "DefSng" / "DefStr" / "DefVar"
```

暗黙的定義ディレクティブは、暗黙的に型付けされたエンティティ（セクション 2.2）の宣言型（セクション 2.2）を決定するために、モジュール（セクション 4.2）内で使用される規則を定義する。このようなエンティティの宣言型は、その名称値（セクション 3.3.5.1）の最初の文字に基づいて決定される。暗黙定義ディレクティブは、そのような文字から宣言型への対応を定義する。

静的セマンティクス

- \<single-letter\> の \<IDENTIFIER\> 要素の名前は、1 つの大文字または小文字のアルファベット（%x0041-005A または %x0061-007A）で<ins>構成されなければならない</ins>。
- \<upper-case-A\> の \<IDENTIFIER\> 要素の名称値は、"A" (%x0041) 1 文字で<ins>構成されなければならない</ins>。
- \<upper-case-Z\> の \<IDENTIFIER\> 要素の名称値は、"Z" (%x005A) 1 文字で<ins>構成されなければならない</ins>。
- \<single-letter\> からなる \<letter-spec\> は、\<single-letter\> の \<IDENTIFIER\> 要素の名称値である文字で始まるすべての \<IDENTIFIER\> トークンの、モジュール内での暗黙宣言型を定義している。

- \<letter-range\> からなる \<letter-spec\>は、\<IDENTIFIER\> トークンをもつすべてのエンティティでその名称値が最初の文字を含む \<first-letter\> \<IDENTIFIER\> 要素の名称値であり、最後の文字を含む \<last-letter\> \<IDENTIFIER\> 要素の名称値である連続する文字の範囲のいずれかの文字から始まっているもので、モジュール内での宣言型を暗黙的に定める。連続する文字の範囲とは、文字の昇順または降順の範囲であり、1 文字で構成することができる。
- \<procedural-module-declaration-section\> または \<class-module-declaration-section\> 内では、\<letter-spec\> プロダクションの間で重複が許されない。
- \<universal-letter-range\> は、モジュール内のすべての \<IDENTIFIER\> に対して単一の宣言型を暗黙的に定義する。

各 \<def-type\> に対応する宣言型は、以下の表で定義される。

| \<def-type\> | 宣言型           |
| ------------ | ---------------- |
| "DefBool"    | Boolean          |
| "DefByte"    | Byte             |
| "DefInt"     | Integer          |
| "DefLng"     | Long             |
| "DefLngLng"  | LongLong         |
| "DefLngPtr"  | LongPtr の別名   |
| "DefCur"     | Currency         |
| "DefSng"     | Single           |
| "DefDbl"     | Double           |
| "DefDate"    | Date             |
| "DefStr"     | String           |
| "DefObj"     | オブジェクト参照 |
| "DefVar"     | Variant          |

エンティティが明示的に型付けされておらず、適用可能な \<def-type\> が存在しない場合、エンティティの宣言型は `Variant` となる。

### 5.2.3 モジュール宣言部

```
common-module-declaration-element = module-variable-declaration
common-module-declaration-element =/ private-const-declaration
common-module-declaration-element =/ private-type-declaration
common-module-declaration-element =/ enum-declaration
common-module-declaration-element =/ private-external-procedure-declaration
```

どのような種類のモジュール（セクション 4.2）でも \<common-module-declaration-element\> を含むことができる。それ以外の宣言は \<procedural-module\> か \<class-module\> のどちらか一方に固有のものである。

#### 5.2.3.1 モジュール宣言の変数リスト

```
module-variable-declaration = public-variable-declaration / private-variable-declaration

global-variable-declaration = "Global"  variable-declaration-list
public-variable-declaration = "Public" ["Shared"] module-variable-declaration-list
private-variable-declaration = ("Private" / "Dim") ["Shared"] module-variable-declaration-list

module-variable-declaration-list = (withevents-variable-dcl / variable-dcl)
      *( "," (withevents-variable-dcl  / variable-dcl) )
variable-declaration-list = variable-dcl *( "," variable-dcl )
```

\<global-variable-declaration\> とオプションの `Shared` キーワード（セクション 3.3.5.1）は、他の Basic 言語の方言や VBA の古いバージョンとの構文互換性を提供する。

静的セマンティクス

- `Shared` キーワードは意味を持たない。
- 同じモジュール（セクション 4.2）に含まれる \<module-variable-declaration\> で定義された各変数（セクション 2.3）は、異なる変数名（セクション 2.3）を<ins>持たなければならない</ins>。
- \<module-variable-declaration\> 内で定義される各変数はモジュール変数であり、同じモジュール内で定義される他のモジュール変数、モジュール定数、列挙体メンバー、プロシージャ（セクション 2.4）の名前と異なる変数名を<ins>持たなければならない</ins>。
- \<global-variable-declaration\> または \<public-variable-declaration\> の一部である変数宣言は、公開変数を宣言している。この変数は、プロジェクト（セクション 4.1）内でアクセス可能である。それを包含するモジュールがクラスモジュール（セクション 4.2）、または非公開モジュール（セクション 5.2.1.4）ではないプロシージャモジュール（セクション 4.2）の場合、変数はそれを包含するプロジェクトを参照しているプロジェクト内でもアクセス可能である。
- \<private-variable-declaration\> の一部である変数宣言は、非公開変数を宣言している。その変数はそのモジュール内でのみアクセス可能である。
- \<public-variable-declaration\> で定義された変数の変数名がプロジェクト名（セクション 4.1）やモジュール名（セクション 4.2）と同じ場合、変数名へのすべての参照は \<public-variable-declaration\> を含むモジュール内で発生しない限りモジュール修飾して<ins>扱われなければならない</ins>。
- \<module-variable-declaration\> で定義された変数は、同じモジュールで定義された \<enum-declaration\> の列挙型名と同じ変数名を持つことができるが、変数名がモジュール修飾されていてもその変数名を用いて参照することはできない。
- \<public-variable-declaration\> で定義された変数が、異なるモジュールの公開されている \<enum-declaration\> の列挙型名と同じ変数名を持つ場合、その変数名への参照は \<public-variable-declaration\> を含むモジュール内で発生しない限りすべてモジュール修飾<ins>されなければらない</ins>。
- \<class-module-code-section\> の \<public-variable-declaration\> で定義された変数の宣言型（セクション 2.2）は、\<private-type-declaration\> や 非公開の列挙型名で定義された UDT（セクション 2.1）でない場合がある。
- プロシージャモジュールに含まれる \<module-variable-declaration-list\> は、\<withevents-variable-dcl\> 要素を<ins>含んではならない</ins>。

実行時セマンティクス

- \<procedural-module-declaration-section\> の要素である \<module-variable-declaration\> で定義された変数は、すべてモジュールエクステント（セクション 2.3）を持っている。
- \<class-module-declaration-section\> の要素である \<module-variable-declaration\> で定義された変数は、クラスのメンバ変数（セクション 2.5）であり、オブジェクトエクステント（セクション 2.3）を持つ。クラスの各インスタンス（セクション 2.5）は対応する個別の変数を含むことになる。

##### 5.2.3.1.1 変数宣言

```
variable-dcl = typed-variable-dcl / untyped-variable-dcl
typed-variable-dcl = TYPED-NAME [array-dim]
untyped-variable-dcl = IDENTIFIER  [array-clause / as-clause]
array-clause = array-dim [as-clause]
as-clause = as-auto-object / as-type
```

静的セマンティクス

- \<typed-variable-dcl\> は変数名（セクション 2.3）を \<TYPED-NAME\> の名称値（セクション 3.3.5.1）とする変数を定義する。
- オプションの \<array-dim\> がない場合、変数の宣言型（セクション 2.2）は \<TYPED-NAME\> の宣言型になる。
- オプションの \<array-dim\> があり、\<bounds-list\> を含まない場合、定義された変数の宣言型は、\<TYPED-NAME\> の宣言型を要素型（セクション 2.1.1）として持つ可変サイズ配列（セクション 2.2）である。
- オプションの \<array-dim\> が存在して \<bounds-list\> を含む場合、定義された変数の宣言型は固定サイズの配列（セクション 2.2）で、\<TYPED-NAME\> の宣言型が要素型となる。次元数、各次元の上限（セクション 2.1）と下限（セクション 2.1）は \<bounds-list\> で定義されたとおりとなる。
- \<untyped-variable-dcl\> に \<as-clause\> が含まれ、更にその中に \<as-auto-object\> 要素が含まれる場合、それは自動インスタンス化変数（セクション 2.5.1）を定義する。\<untyped-variable-dcl\> が \<array-dim\> 要素も含む場合、定義された配列変数の各従属変数（セクション 2.3.1）は自動インスタンス化変数となる。
- \<untyped-variable-dcl\> が \<as-clause\> を（直接または \<array-clause\> の一部としても）含まない場合、暗黙的に型付け（セクション 5.2.2）された宣言であり、その暗黙の宣言型（セクション 5.2.3.1.5）には以下の規則が適用される。
    - \<array-clause\> を含まない暗黙の型付け宣言で定義された変数の宣言型は、その暗黙の宣言型と同じである。
    - \<array-clause\> を含み、\<array-dim\> 要素に \<bounds-list\> を含まない暗黙の型付け宣言で定義された変数の宣言型は、暗黙の宣言型と同じ可変サイズ配列である。
    - \<array-clause\> の \<array-dim\> 要素に \<bounds-list\> が含まれる暗黙の型付け宣言で定義された変数の宣言型は、暗黙の宣言型と同じ固定サイズ配列となる。次元数、各次元の上限と下限は \<bounds-list\> で定義される通りとなる。
- \<untyped-variable-dcl\> に \<as-clause\> を含む \<array-clause\> がある場合、以下のルールが適用される。
    - \<array-clause\> の \<array-dim\> に \<bounds-list\> が含まれていない場合、\<as-clause\> に指定された型を持つ可変サイズ配列となる。
    - \<array-clause\> の \<array-dim\> が \<bounds-list\> を含む場合、定義された変数の宣言型は \<as-clause\> の指定した型を要素とする固定サイズ配列となる。次元数および各次元の上限と下限は \<bounds-list\> で定義される通りとなる。
    - \<as-clause\> が \<as-auto-object\> で構成されている場合、定義された変数の各従属変数は自動インスタンス化変数となる。
- \<untyped-variable-dcl\> に \<as-clause\> が含まれ、\<array-clause\> が含まれない場合、以下のルールが適用される。
    - 定義された変数の宣言型は \<as-clause\> で指定された型となる。
    - \<as-clause\> が \<as-auto-object\> で構成されている場合、定義された変数は自動インスタンス化変数となる。

##### 5.2.3.1.2 WithEvents 変数宣言

```
withevents-variable-dcl = "withevents" IDENTIFIER "as" class-type-name
 
class-type-name = defined-type-expression
```

静的セマンティクス

- \<withevents-variable-dcl\> は \<class-type-name\> 要素で指定された宣言型の変数を定義する。
- \<class-type-name\> 要素の指定型は、少なくとも 1 つのイベントメンバを持つ特定のクラスで<ins>なければならない</ins>。
- \<class-type-name\> 要素の指定型は、この宣言を含むクラスモジュールによって定義されたクラスで<ins>あってはならない</ins>。
    - \<IDENTIFIER\> にアンダースコア文字（[Unicode](./1_はじめに.md) u+005F）を付加した名称値が、この宣言を含むクラスモジュールのイベントハンドラ名の接頭辞となる。
- \<class-type-name\> の指定型は、その \<defined-type-expression\> で参照される宣言型である。

##### 5.2.3.1.3 配列の次元と境界

```
array-dim = "(" [bounds-list] ")"
bounds-list = dim-spec *("," dim-spec)
dim-spec = [lower-bound] upper-bound
lower-bound = constant-expression  "to"
upper-bound = constant-expression
Static Semantics
```

静的セマンティクス

- \<bounds-list\> を持たない \<array-dim\> は可変サイズ配列を表す。
- \<bounds-list\> は最大で 60 個の \<dim-spec\> 要素を含む。
- \<bounds-list\> を持つ \<array-dim\> は、\<bounds-list\> の \<dim-spec\> 要素数と同じ次元数の固定サイズ配列を指定する。
- \<upper-bound\> または <lower-bound\> の \<constant-expression\> は、Long 宣言型と Let 互換なデータ値として<ins>評価されなければならない</ins>。
- 次元の上限は、その次元に対応する \<dim-spec\> の \<upper-bound\> の Long データ値で指定される。
- \<lower-bound\> が存在する場合、その\<constant-expression\> には対応する次元の下限の Long データ値が指定される。
- \<lower-bound\> が存在しない場合、対応する次元の下限は、セクション 5.2.1.2 で規定されるモジュール内のデフォルトの下限値となります。
- 各次元について、下限値は上限値以下で<ins>なければならない</ins>。

##### 5.2.3.1.4 変数の型宣言

型指定は、宣言の指定型を決定する。

```
as-auto-object = "as" "new" class-type-name
as-type = "as" type-spec
type-spec = fixed-length-string-spec  / type-expression
fixed-length-string-spec = "string" "*" string-length
string-length = constant-name / INTEGER
constant-name = simple-name-expression
```

静的セマンティクス

- \<as-auto-object\> 要素の指定型は、その \<class-type-name\> 要素の指定型である。
- \<as-auto-object\> 要素の指定型は、名前付きクラスで<ins>なければならない</ins>。
- \<as-auto-object\> のインスタンス化モードは、\<as-auto-object\> 要素を含むモジュールと同じプロジェクトで定義されていない限り、PublicNotCreatable で<ins>あってはならない</ins>。

- \<as-type\> の指定型は \<type-spec\> 要素の指定型とする。
- \<type-spec\> の指定型はその構成要素の指定型となる。
- \<fixed-length-string-spec\> の指定型は String*n （n は \<string-length\> 要素のデータ値）である。
- \<type-expression\> の指定型は、\<type-expression\> が参照する宣言型となる。
- \<string-length\> の要素である \<constant-name\> は、`Long` 宣言型 と Let 互換な明示的に宣言された定数データ値を<ins>参照しなければならない</ins>。
- \<string-length\> 要素のデータ値は、その \<INTEGER\> 要素のデータ値、または \<constant-name\> が参照するデータ値で、`Long` 型に Let 互換と宣言されているものである。
- \<string-length\> 要素のデータ値は 65,526 以下で<ins>なければならない</ins>。
- \<constant-name\> の \<simple-name-expression\> 要素は、値として<ins>分類されなければならない</ins>。

##### 5.2.3.1.5 暗黙の型判定

\<type-spec\> または \<type-suffix\> によって明示的に宣言型と関連付けられていない \<IDENTIFIER\> は暗黙的に宣言型と関連付けられている場合がある。このような名前の暗黙の宣言型は次のように定義される。

- \<IDENTIFIER\> の名称値の最初の文字が \<IDENTIFIER\> を含むモジュール内の \<def-directive\> の一部である \<letter-spec\> の文字範囲にある場合、その宣言型は セクション 5.2.2 で指定されている通りである。
- それ以外の場合、宣言型は暗黙的に `Variant` となる。

#### 5.2.3.2 Const 宣言

```
public-const-declaration = ("Global" / "Public")  module-const-declaration
private-const-declaration = ["Private"] module-const-declaration
module-const-declaration = const-declaration

const-declaration = "Const"  const-item-list
const-item-list = const-item *[ "," const-item]
const-item = typed-name-const-item / untyped-name-const-item

typed-name-const-item = TYPED-NAME "=" constant-expression
untyped-name-const-item = IDENTIFIER [const-as-clause] "=" constant-expression

const-as-clause = "as" BUILTIN-TYPE
```

静的セマンティクス

- \<const-as-clause\> の \<BUILTIN-TYPE\> 要素は "object" または "[object]" であってはならない。
- 同じモジュールに含まれる \<module-const-declaration\> 内で定義された定数は、それぞれ異なる名前を<ins>持たなければならない</ins>。
- \<module-const-declaration\> 列挙型メンバー名、プロシージャ名と異なる定数名を<ins>持たなければならない</ins>。
- \<public-const-declaration\> の一部である定数宣言は公開定数の宣言となる。この定数は、宣言されたプロジェクト内からアクセス可能である。定数が宣言されたモジュールが非公開でないプロシージャモジュールの場合、そのプロジェクトを参照するプロジェクトからもアクセス可能である。
- \<private-const-declaration\> の一部である定数宣言は非公開定数の宣言となる。この定数は、宣言されたモジュール内でアクセス可能である。
- \<public-const-declaration\> で定義された定数がプロジェクト名やモジュール名と同じ名前を持つ場合、その変数名へのすべての参照は \<public-const-declaration\> を含むモジュール内で発生しない限りモジュール修飾<ins>されなければならない</ins>。
- \<module-const-declaration\> で定義された定数は、同じモジュールで定義された \<enum-declaration\> の列挙型名と同じ定数名を持つことができるが、定数名がモジュール修飾されていてもその定数名を用いて参照することはできない。
- \<public-const-declaration\> で定義された定数が別のモジュールにある公開された \<enum-declaration\> の列挙型名と同じ定数名を持つ場合、定数名へのすべての参照は \<public-const-declaration\> を含むモジュール内で発生しない限りモジュール修飾<ins>されなければならない</ins>。
- \<typed-name-const-item\> は、その名前が \<TYPED-NAME\> 要素の名称値であり、その宣言型が セクション 3.3.5.3 で規定された \<TYPED-NAME\> の \<type-suffix\> に対応する宣言型である定数を定義する。
- \<untyped-name-const-item\> は、その \<IDENTIFIER\> 要素の名称値を名前とする定数を定義する。
- \<untyped-name-const-item\> が \<const-as-clause\> を含まない場合、定数の宣言型はその \<constant-expression\> 要素の宣言型と同じとなる。そうでない場合、定数の宣言型は \<const-as-clause\> の \<BUILTIN-TYPE\> 要素の宣言型となる。
- \<const-item\> 内で使用される \<constant-expression\> は、\<constant-expression\> 内で通常許可される組み込み関数であっても、関数を参照しない場合がある。
- \<const-item\> 内の \<constant-expression\> 要素のデータ値は、その \<const-item\> によって定義された定数の宣言型と互換性が<ins>なければなりません</ins>。
- \<const-item\> によって定義される定数の定数束縛は、その定数の宣言型に Let 互換な \<constant-expression\> のデータ値である。

#### 5.2.3.3 ユーザ定義型（UDT）宣言

```
public-type-declaration = ["global" / "public"]  udt-declaration
private-type-declaration = "private" udt-declaration
udt-declaration = "type" untyped-name EOS udt-member-list EOS "end" "type"
udt-member-list = udt-element *[EOS udt-element]
udt-element = rem-statement / udt-member
udt-member = reserved-name-member-dcl / untyped-name-member-dcl
untyped-name-member-dcl = IDENTIFIER optional-array-clause
reserved-name-member-dcl = reserved-member-name as-clause
optional-array-clause = [array-dim] as-clause

reserved-member-name = statement-keyword / marker-keyword / operator-identifier / special-form / reserved-name / literal-identifier / reserved-for-implementation-use / future-reserved
```

静的セマンティクス

- \<udt-declaration\> に含まれる UDT 名は、`Type` キーワード（セクション 3.3.5.1）に続く \<untyped-name\> の名前値となる。
- 各 \<udt-declaration\>は、UDT 名で識別される一意の宣言型と一意の UDT データ型を定義する。
- \<public-const-declaration\> の一部である UDT 宣言は、公開 UDT を宣言する。 UDT はそのプロジェクト内でアクセス可能である。宣言を含むモジュールが非公開モジュールでないプロシージャモジュールである場合、UDT はそのプロジェクトを参照するプロジェクトからでもアクセス可能である。
- \<private-const-declaration\> の一部である UDT 宣言は、非公開 UDT を宣言する。UDT はそのモジュール内でアクセス可能である。
- \<udt-declaration\> が \<private-type-declaration\> の要素である場合、その UDT 名は同じモジュール内の \<enum-declaration\> や他の \<udt-declaration\> のUDT 名と同じにすることはできない。
- \<udt-declaration\> が \<public-type-declaration\> の要素である場合、その UDT 名はそれを含むプロジェクトのどのモジュール内においても、公開された \<enum-declaration\> の列挙型名または \<public-type-declaration\> の UDT 名と同一にすることはできない。
- \<udt-declaration\> が \<public-type-declaration\> の要素である場合、その UDT 名は現在の VBA 環境内のプロジェクト名やライブラリ名、\<udt-declaration\> を含むプロジェクト内のモジュール名と同じにすることはできない。
- \<reserved-member-name\> の名称値は、その予約済み識別子名のテキストである。\<udt-member-list\> の中の少なくとも 1 つの \<udt-element\> は \<udt-member\> で<ins>構成されなければならない</ins>。
- \<udt-member\> が \<untyped-name-member-dcl\> の場合、その UDT メンバ名は \<untyped-name-member-dcl\> の \<IDENTIFIER\> 要素の名称値となる。
- \<udt-member\> が \<reserved-name-member-dcl\> の場合、その UDT メンバ名は \<reserved-name-member-dcl\> の \<reserved-member-name\> 要素の名称値となる。
- \<udt-member-list\> 内の各 \<udt-member\> は、異なる UDT メンバ名を<ins>持たなければならない</ins>。
- 各 \<udt-member\> は、\<udt-declaration\> に含まれる UDT 名で識別される UDT データ型の名前付き要素を定義する。
- 各 \<udt-member\> は、\<udt-declaration\> に含まれる UDT 名で識別される UDT データ型と宣言型の名前付き要素を定義する。
- \<udt-member\> で定義される UDT 要素の宣言型は次のように定義される。
    - \<udt-member\> が \<bounds-list\> を含まない \<array-dim\> を含む場合、UDT 要素の宣言型は可変サイズ配列であり、その要素型は \<udt-member\> に含まれる \<as-clause\> である。
    - \<udt-member\> が \<bounds-list\> を含む \<array-dim\> を含む場合、UDT 要素の宣言型は固定サイズ配列であり、その要素型は \<udt-member\> に含まれる \<as-clause\> の指定型である。次元数、各次元の上限と下限は \<bounds-list\> で定義される通りである。
    - それ以外の場合、UDT 要素の宣言型は、\<as-clause\> の指定型となる。
- \<udt-member\> が \<as-clause\> を含み、それが \<as-auto-object\> で構成されている場合、宣言型が含む \<udt-declaration\> の UDT 名である任意の変数に対応する従属変数（または配列変数の各従属変数）は自動インスタンス化変数となる。

#### 5.2.3.4 列挙型宣言

```
global-enum-declaration = "global" enum-declaration 
public-enum-declaration = ["public"] enum-declaration
private-enum-declaration = "private" enum-declaration
enum-declaration = "enum" untyped-name EOS member-list EOS "end" "enum"
enum-member-list = enum-element *[EOS enum-element]
enum-element = rem-statement / enum-member
enum-member = untyped-name [ "=" constant-expression]
```

\<global-enum-declaration\> は、BASIC 言語の他の方言や VBA の歴史的なバージョンとの構文上の互換性を提供する。

静的なセマンティクス

- Enum キーワード（セクション 3.3.5.1）に続く \<untyped-name\> の名称値値は、それを含む \<enum-declaration\> の列挙型名である。
- \<global-variable-declaration\> または \<public-enum-declaration\> の一部である列挙型宣言は、公開された列挙型を宣言している。列挙型とそのメンバは、そのプロジェクト内でアクセス可能である。列挙型が宣言されたモジュールがクラスモジュールまたはプロシージャモジュールで非公開モジュールでない場合、列挙型とそのメンバはそのプロジェクトを参照するプロジェクトからでもアクセス可能である。
- \<private-enum-declaration\> の一部である列挙型宣言は、非公開の列挙型を宣言している。この列挙型とそのメンバは、そのモジュール内でアクセス可能である。
- \<private-enum-declaration\> の列挙型名は、他の \<enum-declaration\> の列挙型名や同一モジュール内の \<udt-declaration\> の UDT 名と同じにすることはできない。
- \<public-enum-declaration\> の列挙型名は、それを含むプロジェクトのどのモジュール内においても、他の公開された \<enum-declaration\> の列挙型名、または公開された \<udt-declaration\> の UDT 名と同一にすることはできない。
- \<public-enum-declaration\> の列挙型名は、現在の VBA 環境内のプロジェクトやライブラリの名前、または \<enum-declaration\> を含むプロジェクト内のモジュールと同じ名前にすることはできない。

- \<enum-member-list\> のうちの少なくとも 1 つの \<enum-element\> は \<enum-member\> で<ins>構成されなければならない\<ins>。
- \<enum-member\> の名前は、その \<untyped-name\> の名称値である。
- \<enum-member-list\> 内の各 \<enum-member\> は、それぞれ異なる列挙型メンバ名を<ins>持たなければならない</ins>。
- 列挙型のメンバ名は、同じモジュール内で定義されている変数名や定数名と同じでない場合がある。
- \<enum-member\> が \<constant-expression\> を含む場合、 \<constant-expression\> のデータ値は Long データ型に<ins>保たれなければならない</ins>。
- \<enum-member\> の \<constant-expression\> には、その \<enum-member\> の列挙型メンバ名への参照が含まれていない場合がある。
- \<enum-member\> の \<constant-expression\> には、その \<enum-member-list\> で先行する \<enum-member\> のメンバ名への参照が含まれていない可能性がある。
- \<enum-member\> の \<constant-expression\> には、\<enum-declaration\> の \<enum-member\> を含むモジュール宣言セクションで先行するすべての \<enum-member\> のメンバ名への参照が含まれていない可能性がある。
- \<enum-member\> が \<constant-expression\> を含む場合、 \<enum-member\> のデータ値は \<constant-expression\> を `Long` 型に強制したものとなる。\<enum-member\> が \<constant-expression\> を含まず、かつ \<enum-member-list\> の最初の要素である場合、そのデータ値は 0 である。\<enum-member\> が \<constant-expression\> を含まず、かつ \<enum-member-list\> の最初の要素でもない場合、そのデータ値は \<enum-member-list\> を含む前の要素より 1 大きい値である。
- \<enum-member\> の宣言型は `Long` である。
- 列挙型名（プロジェクト名で修飾されることもある）が任意の宣言の \<as-type\> 部分に表れた場合、その意味は列挙型名が宣言型 `Long` に置き換えられた場合と同じである。

#### 5.2.3.5 外部プロシージャ宣言

```
public-external-procedure-declaration = ["public"] external-proc-dcl
private-external-procedure-declaration = "private" external-proc-dcl

external-proc-dcl = "declare" ["ptrsafe"] (external-sub / external-function)

external-sub = "sub" subroutine-name lib-info [procedure-parameters]
external-function = "function" function-name lib-info  [procedure-parameters] [function-type]

lib-info = lib-clause [alias-clause]
lib-clause = "lib" STRING
alias-clause = "alias" STRING
```

静的セマンティクス

- \<public-external-procedure-declaration\> 要素と \<private-external-procedure-declaration\> 要素は外部プロシージャである。
- \<public-external-procedure-declaration\> 要素と \<private-external-procedure-declaration\> 要素はプロシージャ宣言であり、セクション 5.3.1 で定義したプロシージャ宣言の静的セマンティクスが適用される。
- \<external-sub\> 要素はサブルーチン宣言であり、\<external-function\> は関数宣言である。（訳注：逆になっていたので訂正した）
- 外部プロシージャ名が大文字と小文字を区別して解釈されるかどうかは実装定義である。
- \<alias-clause\> の \<STRING\> 要素の最初の文字が %x0023 ("#") の場合、その要素は序数エイリアスであり、文字列の残りの部分は字句トークン文法の \<integer-literal\> 規則の定義に<ins>従わなければならない</ins>。\<integer-literal\> のデータ値は 0 から 32,767 の範囲で<ins>なければならない</ins>。
- \<alias-clause\> の \<STRING\> 要素のデータ値の最初の文字が %x0023 ("#") でない場合、その \<STRING\> 要素のデータ値は実装定義された構文に<ins>従わなければならない</ins>。
- 実装は、外部プロシージャの宣言におけるパラメータ型、関数型、パラメータ機構、オプションパラメータと `ParamArray` パラメータの使用に関する制限を<ins>追加定義してもよい</ins>。
- 実装は `PtrSafe` キーワードを指定しない外部プロシージャの宣言に対する追加の制限を<ins>定義してもよい</ins>。

実行時セマンティクス

- 外部プロシージャが呼び出されたとき、その \<lib-clause\> の \<STRING\> 要素のデータ値は、VBA 言語以外の実装定義によって利用可能なプロシージャの集合を識別するために、実装定義された方法で使用される。
- 外部プロシージャが呼び出されたとき、利用可能な中からプロシージャを選択するために、そのオプションの \<alias-clause\> の \<STRING\> 要素のデータ値が実装定義された方法で使用される。\<alias-clause\> が存在しない場合、利用可能な中からプロシージャを選択するために、プロシージャ名が実装定義された方法で使用される。
- 外部プロシージャは、\<external-proc-dcl\> の \<procedure-parameters\> と \<function-type\> 要素を含む \<subroutine-declaration\> または \<function-declaration\> によって、VBA 言語で定義されたプロシージャであるかのように呼び出され実引数が渡される。

#### 5.2.3.6 循環モジュールの依存関係

静的セマンティクス

- 定数宣言（セクション 5.2.3.2）、列挙型宣言（セクション 5.2.3.4）、UDT 宣言（セクション 5.2.3.3）、実装ディレクティブ（セクション 5.2.4.2）、イベント宣言（セクション 5.2.4.3）などを含むモジュール間の循環参照は許可されていない。
- これらの宣言形式のいずれかを含むモジュール間の循環的な依存関係は、依存関係の連鎖が他の形式の宣言を含んでいたとしても許可されない。
- これらの特定の宣言形式を含まないモジュール間の循環的な依存関係の連鎖は許可される。

### 5.2.4 クラスモジュール宣言

クラスモジュールは、VBA 環境内の他のモジュールから参照できる宣言型として名前付きクラスを定義する。

#### 5.2.4.1 構文外で定義されるクラス特性

クラスの特性のいくつかは、\<class-module-body\> の中では定義されず、代わりにモジュールの属性値や場合によっては実装定義される機構を使って定義される。

このクラスモジュールで定義されるクラスの名前は、クラスモジュール自体の名前である。

##### 5.2.4.1.1 クラスのアクセシビリティとインスタンス化

クラスをその名前で参照できるかどうかは、そのクラス定義のアクセシビリティによって決定される。アクセシビリティは、クラスの新しいインスタンスを作成するためにクラス名を使用する能力とは異なる。

クラスのアクセシビリティとインスタンス化の特性は、次の表で定義されるように、そのクラスモジュール宣言のモジュール属性によって決定される。

| インスタンス化モード | 意味                                                                                                                                                                                                                                                                                                                                                       | 属性値                                  |
| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------- |
| 非公開（既定）       | このクラスはそのプロジェクト内でのみアクセス可能。<br/><br/>クラスのインスタンスは、そのクラスを定義しているプロジェクトに含まれるモジュールによってのみ作成することができる。                                                                                                                                                                             | VB_Exposed=False<br/>VB_Creatable=False |
| 公開かつ作成可能     | このクラスはそのプロジェクト内及びそのプロジェクトを参照するプロジェクト内でアクセス可能。<br/><br/>クラスのインスタンスは、そのプロジェクト内のモジュールによってのみ作成することができる。他のプロジェクトのモジュールは、宣言型としてクラス名を参照することはできるが、`new` や `CreateObject` 関数を使用してクラスをインスタンス化することはできない。 | VB_Exposed=True<br/>VB_Creatable=False  |
| 公開かつ作成不可能   | このクラスは、そのプロジェクト内及びそのプロジェクトを参照するプロジェクト内でアクセス可能。<br/><br/>このクラスにアクセスできるモジュールはクラスのインスタンスを作成することができる。                                                                                                                                                                   | VB_Exposed=True<br/>VB_Creatable=True   |

実装では、ライブラリプロジェクトで定義されたクラスに適用されるインスタンス化モードを追加で定義してもよい。

##### 5.2.4.1.2 デフォルトインスタンス変数の静的セマンティクス

- クラスモジュールは `VB_PredeclaredId` 属性または `VB_GlobalNamespace` 属性が "True" の場合にデフォルトインスタンス変数を持つ。
- `VB_GlobalNamespace` 属性が "True" である場合、クラスモジュールはデフォルトインスタンス変数を持つ。このデフォルトインスタンス変数は、\<class-type-name\> がクラス名である \<as-autoobject\> 要素を含む \<module-variable-declaration\> で宣言されているかのように、モジュールエクステントで生成される。
- このクラスモジュールの `VB_PredeclaredId` 属性が "True" の場合、デフォルトインスタンス変数にはクラス名が名前として与えられる。この名前付き変数を `Set` による代入に用いることはできない。このクラスモジュールの `VB_PredeclaredId` 属性の値が "True" でない場合、デフォルトインスタンス変数は公開される名前を持たない。
- `VB_GlobalNamespace` 属性が "True" の場合、クラスモジュールはグローバルクラスモジュールとみなされ、セクション 5.6.10 に規定されるデフォルトインスタンスのメンバへの単純な名前アクセスが許可される。
- `VB_PredeclaredId` 属性と `VB_GlobalNamespace` 属性の両方が "True" の場合、両方の属性のセマンティクスによって同じデフォルトインスタンス変数が共有されることに注意すること。

##### 5.2.4.2 実装ディレクティブ

```
implements-directive = "Implements" class-type-name
```

静的セマンティクス

- \<implements-directive\> は、拡張モジュール内では使用できない。
- \<class-type-name\> で指定されたクラスはインターフェースクラスと呼ばれる。
- インターフェースクラスは、\<implements-directive\> を含むクラスモジュールで定義されたクラスである必要はない。
- 同じクラスモジュール内の複数の \<implements-directive\> で、特定のクラスをインターフェースクラスとして指定することはできない。
- 同じクラスモジュールに含まれる全てのインターフェースクラスの非修飾クラス名は、互いに<ins>異なるものでなければらない</ins>。
- インターフェースクラスのクラス名にアンダースコア文字（[Unicode](./1_はじめに.md) u+005F）を付加したものが、 このディレクティブを含むクラスモジュール内の実装インターフェース名の接頭辞となる。
- クラスモジュールが複数の \<implements-directive\> を含んでいる場合、その実装インターフェース名の接頭辞のすべてにおいて、他の実装名プレフィックスの頭文字とすることはできない。
- クラスが持つ公開変数やメソッドの名前にアンダースコア文字（Unicode u+005F）が含まれている場合、そのクラスはインターフェースクラスとして使用することはできない。
- \<implements-directive\> を含むクラスモジュールは、 インターフェースクラスのクラスモジュールに含まれる公開メソッドの宣言に対応する実装名の宣言を<ins>含まなければならない</ins>。
- \<implements-directive\> を含むクラスモジュールは、 インターフェースのクラスモジュールに含まれる公開変数宣言に対応する実装名宣言を<ins>含まなければならない</ins>。必要な実装名宣言は、以下のように宣言された公開変数の型に依存する。
    - 宣言された変数の型が `Variant` の場合、\<property-get-declaration\> と \<property-lhs-declaration\> を含む 3 つの対応する実装名の宣言が<ins>なければならない</ins>。
    - 宣言された変数の型が `Object` または名前付きクラスの場合、\<property-get-declaration\> と \<property-lhs-declaration\> を含む 2 つの対応する実装名の宣言が<ins>なければならない</ins>。
    - 宣言された変数の型がそれ以外の場合、\<property-get-declaration\> と \<property-lhs-declaration\> の 2 つの対応する実装名の宣言が<ins>なければならない</ins>。


#### 5.2.4.3 イベント宣言

```
event-declaration = ["Public"]
"Event" IDENTIFIER [event-parameter-list]
event-parameter-list = "(" [positional-parameters] ")"
```

静的セマンティクス

- \<event-declaration\> は、そのクラスモジュールが定義するクラスのイベントメンバを定義する。
- `Public` キーワード（セクション 3.3.5.1）で始まらない \<event-declaration\> は、`Public` が存在する場合と同じ意味をもつ。
- イベントメンバのイベント名は、\<IDENTIFIER\> の名称値とする。
- クラスモジュール宣言セクション内の各 \<event-declaration\> は、異なるイベント名を<ins>指定しなければならない</ins>。
- イベント名は、同じモジュール内で定義されているモジュール変数名、モジュール定数名、列挙型メンバ名、プロシージャ名と同じ名称値を持つことができる。
- イベント名は、アンダースコア文字（[Unicode](./1_はじめに.md) u+005F）を<ins>含んではならない</ins>。

実行時セマンティクス

- \<event-parameter-list\> に含まれる \<positional-param\> 要素は、いかなる変数や変数束縛も定義しない。それらは単に、関連付けられたイベント名を参照する \<raiseevent-statement\> に提供されなければならない実引数を記述するだけである。

## 5.3 モジュールのコード部の構造

```
procedural-module-code-section = *( LINE-START  procedural-module-code-element LINE-END)
class-module-code-section = *( LINE-START  class-module-code-element LINE-END)

procedural-module-code-element = common-module-code-element
class-module-code-element = common-module-code-element / implements-directive

common-module-code-element = rem-statement / procedure-declaration

procedure-declaration = subroutine-declaration / function-declaration /        property-get-declaration / property-LHS-declaration
```

VBA 言語では、プロシージャを定義するためにいくつかの構文形式が使用されている。この仕様のいくつかの文脈では、様々な種類の宣言を参照する必要がある。次の表は、この仕様で使用される宣言の種類と、どの文法生成を使用するかを定義している。セルにチェックマークが表示されている場合、その列で定義されている宣言の種類は、その行の文法生成で定義されている宣言を参照することができる。

| 文法ルール                   | プロシージャ宣言 | メソッド宣言 | プロパティ宣言 | サブルーチン宣言 | 関数宣言 |
| ---------------------------- | :--------------: | :----------: | :------------: | :--------------: | :------: |
| \<subroutine-declaration\>   | ✓                | ✓            |                | ✓                |          |
| \<function-declaration\>     | ✓                | ✓            |                |                  | ✓        |
| \<external-sub\>             | ✓                |              |                | ✓                |          |
| \<external-function\>        | ✓                |              |                |                  | ✓        |
| \<property-get-declaration\> | ✓                | ✓            | ✓              |                  | ✓        |
| \<property-lhs-declaration\> | ✓                | ✓            | ✓              | ✓                |          |

### 5.3.1 プロシージャ宣言

```
subroutine-declaration = procedure-scope [initial-static]
               "sub" subroutine-name [procedure-parameters] [trailing-static] EOS
                        [procedure-body EOS]
               [end-label] "end" "sub" procedure-tail

function-declaration = procedure-scope [initial-static]
                        "function" function-name [procedure-parameters] [function-type] [trailing-static] EOS
                 [procedure-body EOS]
                  [end-label]  "end" "function" procedure-tail

property-get-declaration = procedure-scope [initial-static]
                 "Property" "Get"
                 function-name [procedure-parameters] [function-type] [trailing-static] EOS
                           [procedure-body EOS]
                           [end-label] "end" "property" procedure-tail

property-lhs-declaration = procedure-scope [initial-static]
                 "Property" ("Let" / "Set")
                  subroutine-name property-parameters [trailing-static] EOS
              [procedure-body EOS]
                 [end-label] "end" "property" procedure-tail

end-label = statement-label-definition
procedure-tail = [WS] LINE-END / single-quote comment-body /  ":" rem-statement
```

静的セマンティクス

- 関数宣言は関数結果変数と呼ばれるローカル変数を暗黙的に定義する。この変数名と宣言型は関数と共有されスコープは関数本体となる。
- 関数宣言はその名前がその \<function-name\> の名称値であるプロシージャを定義し、サブルーチン宣言はその名前がその \<subroutine-name\> の名称値であるプロシージャを定義する。
- 関数宣言の \<function-name\> 要素が \<TYPED-NAME\> の場合、関数宣言に \<function-type\> 要素が含まれていない可能性がある。
- 関数宣言の宣言型は次のように定義される。
    - 関数宣言の \<function-name\> 要素が \<TYPED-NAME\> である場合、関数宣言の宣言型はセクション 3.3.5.3 で指定されている \<TYPED-NAME\> の \<type-suffix\> に対応する宣言型である。
    - 関数宣言の \<function-name\> 要素が \<TYPED-NAME\> ではなく、関数宣言に \<function-type\> 要素が含まれていない場合、宣言型は、セクション 5.2.3.1.5 で指定されている暗黙型である。
    - 関数宣言に \<function-type\> 要素が含まれる場合、関数宣言の宣言型は \<function-type\> 要素の指定型である。
- \<class-module-code-section\> の一部である関数宣言の宣言型は、\<private-type-declaration\> によって定義された UDT ではない可能性がある。
- 関数宣言の宣言型は、非公開列挙名ではない可能性がある。
- オプションの \<end-label\> が存在する場合、その \<statement-label\> には \<procedure-body\> 内で定義された \<statement-label\> とは異なるラベル値が含まれている必要がある。

実行時セマンティクス

- プロシージャに含まれるコードはプロシージャの呼び出し中に実行される。
- プロシージャの各呼び出しには、プロシージャ内の各 `ByVal` パラメータ、またはプロシージャエクステント変数宣言に対応する個別の変数がある。
- 関数宣言の各呼び出しには、個別の関数結果変数がある。
- 関数結果変数にはプロシージャエクステントがある。
- \<class-module-code-section\> 内で定義されたプロシージャ宣言の \<procedure-body\> 内での予約名 `Me` の宣言型は、そのクラスモジュールによって定義された名前付きクラスであり、"me" のデータ値は関数の現在アクティブな呼び出しの対象オブジェクトへのオブジェクト参照である。
- プロシージャの呼び出しは次の手順で構成される。
    1. `ByVal` パラメータに対応するプロシージャエクステント変数を作成する。
    2. セクション 5.3.1.11 で定義されているように実引数を処理する。
    3. プロシージャのエラー処理ポリシー（セクション 5.4.4）をデフォルトポリシーに設定する。
    4. 関数結果変数と、プロシージャ内で宣言されたプロシージャエクステントのローカル変数を作成する。
    5. \<procedure-body\> を実行する。
    6. プロシージャが関数の場合、関数結果変数のデータ値を関数の結果として呼び出し側に返す。
    7. 呼び出しが完了し、呼び出し側で実行が継続される。

#### 5.3.1.1 プロシージャスコープ

```
procedure-scope = ["global" / "public" / "private" / "friend"]
```

静的セマンティクス

- \<procedure-declaration\> に \<procedure-scope\> 要素を含まないものは、Public キーワード（セクション 3.3.5. 1）からなる \<procedure-scope\> 要素を含む場合と同じ意味を持つ。
- `Public` キーワード または `Global` キーワードからなる \<procedure-scope\> 要素を含む \<procedure-declaration\> は、公開プロシージャを宣言している。このプロシージャはそのプロジェクト内でアクセス可能である。そのモジュールがクラスモジュールまたは非公開モジュールでないプロシージャモジュールである場合、そのプロシージャはそのプロジェクトを参照するプロジェクト内でもアクセス可能である。
- `Friend` キーワードからなる \<procedure-scope\> 要素を含む \<procedure-declaration\> は、フレンドプロシージャを宣言している。このプロシージャはそのプロジェクト内でアクセス可能である。
- `Private` キーワードからなる \<procedure-scope\> 要素を含む \<procedure-declaration\> は、非公開プロシージャを宣言する。このプロシージャは、そのモジュール内でアクセス可能である。
- `Global` キーワードからなる \<procedure-scope\> は \<class-module-code-section\> に含まれる \<procedure-declaration\> の要素でない場合がある。
- `Friend` キーワードで構成される \<procedure-scope\> は、\<procedural-module-code-section\> に含まれる \<procedure-declaration\> の要素にならない場合がある。

#### 5.3.1.2 静的プロシージャ

```
initial-static = "static"
trailing-static = "static"
```

静的セマンティクス

- \<initial-static\> 要素または \<trailing-static\> 要素を含む \<procedure-declaration\> は、静的プロシージャを宣言している。
- \<procedure-declaration\> に \<initial-static\> 要素と \<trailing-static\> 要素の両方が含まれることはない。

実行時セマンティクス

- 静的プロシージャの \<procedure-body\> 内で宣言されたすべての変数は、モジュールエクステントを持つ。
- 非静的プロシージャの \<procedure-body\> 内で宣言されたすべての変数は、プロシージャエクステントを持つ。

#### 5.3.1.3 プロシージャ名

```
subroutine-name = IDENTIFIER / prefixed-name
function-name = TYPED-NAME / subroutine-name
prefixed-name = event-handler-name / implemented-name / lifecycle-handler-name
```

静的セマンティクス

- プロシージャ宣言内のプロシージャ名は、それが含まれる \<subroutine-name\> または \<function-name\> 要素の名称値である。
- 公開された可視性であるプロシージャ宣言が、プロジェクト名またはモジュール名と同じプロシージャ名をもつ場合、そのプロシージャを定義するモジュール内で参照が発生しない限りプロシージャ名へのすべての参照はそのプロジェクト名またはモジュール名で明示的に<ins>修飾されなければならない</ins>。

#### 5.3.1.4 関数の型宣言

```
function-type = "as" type-expression [array-designator]
array-designator = "(" ")"
```

静的セマンティクス

- \<array-designator\> 要素を含まない \<function-type\> の指定型は、その \<type-expression\> 要素で参照される宣言型となる。
- \<array-designator\> 要素を含む \<function-type\> の指定型は、\<type-expression\> 要素で参照される宣言型を持つ可変サイズ配列となる。

#### 5.3.1.5 仮引数リスト

```
procedure-parameters = "(" [parameter-list] ")"
property-parameters = "(" [parameter-list ","] value-param ")"

parameter-list = (positional-parameters "," optional-parameters ) /
                 (positional-parameters  ["," param-array]) /
                 optional-parameters /
                 param-array

positional-parameters = positional-param *("," positional-param)
optional-parameters = optional-param *("," optional-param)
value-param = positional-param
positional-param = [parameter-mechanism] param-dcl
optional-param = optional-prefix param-dcl [default-value]
param-array = "paramarray" IDENTIFIER "(" ")" ["as" ("variant" / "[variant]")]

param-dcl = untyped-name-param-dcl / typed-name-param-dcl
untyped-name-param-dcl = IDENTIFIER [parameter-type]
typed-name-param-dcl = TYPED-NAME [array-designator]
optional-prefix = ("optional" [parameter-mechanism]) / ([parameter-mechanism] ("optional"))
parameter-mechanism = "byval" / " byref"
parameter-type = [array-designator] "as" (type-expression / "Any")
default-value = "=" constant-expression
```

静的セマンティクス

- \<parameter-type\> 要素は、\<external-proc-dcl\> の一部である場合にのみキーワード `Any` を含める。
- \<typed-name-param-dcl\> の名前は \<TYPED-NAME\> 要素の名前になる。
- \<untyped-name-param-dcl\> の名称値は \<IDENTIFIER\> 要素の名称値です。
- \<param-dcl\> の名前は構成要素である \<untyped-name-param-dcl\> または \<typed-name-param-dcl\> の名前になる。
- \<positional-param\> 要素や \<optional-param\> 要素の名前は、その \<param-dcl\> 要素の名前である。
- \<param-array\> 要素の名前は \<IDENTIFIER\> 要素の名前になる。
- 同じ \<parameter-list\>, \<property-parameters\>, \<event-parameter-list\> の要素である \<positional-param\>, \<optional-param\>, \<param-array\> はそれぞれ個別の名前を<ins>持たなければならない</ins>。
- 関数宣言の要素である \<positional-param\>, \<optional-param\>, \<param-array\> の名前は、関数宣言の名前と<ins>異なっていなければならない</ins>。
- \<positional-param\>, \<optional-param\>, \<param-array\> の名前は、\<procedure-body\> 内の \<local-variable-declaration\>, \<static-variable-declaration\>, \<redim-statement\>, \<local-const-declaration\> で定義した変数名とは異なる可能性がある。
- \<positional-param\>, \<optional-param\>, \<value-param\> の宣言型は、その構成要素の \<param-dcl\> の宣言型となる。
- \<untyped-name-param-dcl\> からなる \<param-dcl\> の宣言型は以下のように定義される。
    - オプションの \<parameter-type\> 要素が存在しない場合、宣言型は セクション 5.2.3.1.5 で規定される \<IDENTIFIER\> の暗黙型となる。
    - 指定されたオプションの \<parameter-type\> 要素が存在するが \<array-designator\> 要素を含まない場合、宣言型はその \<type-expression\> 要素で参照される宣言型となる。
    - オプションの \<parameter-type\> 要素があり \<array-designator\> 要素を含む場合、宣言型は \<type-expression\> 要素が参照する宣言型を要素とする可変サイズ配列になる。
- \<typed-name-param-dcl\> からなる \<param-dcl\> の宣言型は次のように定義される。
    - オプションの \<array-designator\> 要素が存在しない場合、セクション 3.3.5.3 で規定される \<TYPED-NAME\> の \<type-suffix\> に対応する宣言型となります。
    - オプションの \<array-designator\> 要素が存在する場合、定義された変数の宣言型は、セクション 3.3.5.3 で指定された \<TYPED-NAME\> の \<type-suffix\> に対応する要素の宣言型で可変サイズ配列になる。
- \<class-module-code-section\> 内のイベント宣言や公開プロシージャ宣言に含まれる \<param-dcl\> の宣言型は、非公開 UDT、プロシージャモジュールで定義された公開 UDT、非公開列挙型名でない可能性がある。
- \<optional-param\> の宣言型は UDT でない可能性がある。
- \<optional-param\> の宣言型が `Variant` でなく、適用可能な \<def-directive\> によって暗黙的に型が指定された場合、\<default-value\> が<ins>指定されなければならない</ins>。
- \<default-value\> は仮引数のデフォルト値を指定する。`Variant` 仮引数に \<default-value\> が指定されない場合、デフォルト値は標準エラーコード 448（名前指定実引数が見つからない）に解決される実装定義のエラー値となる。`Variant` でない仮引数に \<default-value\> が指定されない場合、デフォルト値はその仮引数の宣言型となる。
- \<positional-param\> または \<optional-param\> 要素に \<parameter-mechanism\> 要素を含まないものは、キーワード `ByRef` からなる \<parameter-mechanism\> 要素を含む場合と同じ意味を持つ。
- キーワード `ByVal` からなる \<parameter-mechanism\> 要素を含む \<param-dcl\> は、\<array-designator\> 要素を含まないかもしれない。
- \<param-array\> の \<IDENTIFIER\> の宣言型は `Variant` の可変サイズ配列である。

実行時セマンティクス

- 関数の各呼び出しは個別の関数結果変数を持つ。
- 関数結果変数はプロシージャーエクステントを持つ。
- キーワード `ByVal` からなる \<parameter-mechanism\> 要素を含む各 \<positional-param\> または \<optional-param\> はプロシージャエクステントを持ち、その宣言型が構成要素の \<param-dcl\> 要素の宣言型となるローカル変数を定義する。対応するパラメータ名はそのローカル変数に束縛される。
- キーワード `ByVal` からなる \<parameter-mechanism\> 要素を含む各 \<positional-param\> は、対応する位置指定実引数に対応する既存変数へのローカル名の束縛を定義する．
- キーワード `ByRefP からなる \<parameter-mechanism\> 要素を含む各 \<optional-param\> は、構成要素 \<param-dcl\> の宣言型であり、プロシージャエクステントを持つローカル変数を定義する。
    - もしこのプロシージャの呼び出しに \<optional-param\> に対応する実引数が含まれていなければ、仮引数名はその呼び出しのためのローカル変数に束縛される。
    - \<optional-param\> に対応する実引数が含まれる場合、仮引数名はその実引数に対応する既存変数に局所的に束縛される。
- プロシージャを呼び出すと、対応する実引数を持たない各 \<optional-param\> の構成要素である \<default-value\> のデータ値が、その \<optional-param\> の仮引数名の変数束縛に割り当てられる。
- メソッドである各プロシージャには、メソッドの呼び出しの対象オブジェクトに対応するカレントオブジェクトと呼ばれる暗黙の `ByVal` 仮引数が存在する。カレントオブジェクトは、プロシージャエクステントを持つ匿名ローカル変数として機能し、その宣言型はメソッド宣言を含むクラスモジュールのクラス名である。メソッドがアクティブである間、現在のオブジェクト変数のデータ値はそのプロシージャ呼び出しの対象オブジェクトとなる。カレントオブジェクトは、メソッドの \<procedure-body\> 内で `Me` キーワードを使用してアクセスされるが、割り当てられたり変更されたりすることはない。
- プロシージャの \<parameter-list\> に \<param-array\> 要素がある場合、プロシージャの各呼び出しは引数配列という実体を定義し、それがあたかも `Variant` 宣言型の要素を持つ "ByRef" \<positional-param\> 配列であるかのように動作する。引数配列の要素へのアクセスは、あたかも名前付き位置仮引数へのアクセスのように振る舞う。実引数はセクション 5.3.1.11 に定義されるように 引数配列の要素に束縛される。

#### 5.3.1.6 サブルーチンと関数の宣言

静的セマンティクス

- 各 \<subroutine-declaration\> と \<function-declaration\> は、同じモジュール内で定義されている他のモジュール変数名、モジュール定数名、列挙型メンバ名、プロシージャ名とは異なるプロシージャ名を<ins>持たなければならない</ins>。

#### 5.3.1.7 プロパティ宣言

静的セマンティクス

- キーワード `Let` を含む \<property-LHS-declaration\> は、Let プロパティ宣言である。
- キーワード `Set` を含む \<property-LHS-declaration\> は Set プロパティ宣言である。
- 各プロパティ宣言は、同じモジュール内で定義された他のモジュール変数、モジュール定数、列挙型メンバ名、外部プロシージャ、\<function-declaration\>、\<subroutine-declaration\> の名前と異なるプロシージャ名を<ins>持たなければならない</ins>。
- モジュール内の各 \<property-get-declaration\> は異なる名前を<ins>持たなければならない</ins>。
- モジュール内の各 Let プロパティ宣言は異なる名前を<ins>持たなければならない</ins>。
- モジュール内の各 Set プロパティ宣言は異なる名前を<ins>持たなければならない</ins>。
- モジュール内では、\<property-get-declaration\>、Let プロパティ宣言、Set プロパティ宣言でプロシージャ名を共有することができる。

- モジュール内でプロシージャ名を共有するすべてのプロパティ宣言は、\<positional-parameters\>, \<optional-parameters\>, \<param-array\> 要素の数、対応する仮引数の名称値、対応する仮引数の宣言型、対応する仮引数に実際に使用する \<parameter-mechanism\> が、等しい \<parameter-list\> 要素で<ins>なければならない</ins>。しかし、対応する \<optional-param\> 要素は、その \<default-value\> 要素の存在とデータ値が異なることがあり、\<parameter-mechanism\> が暗黙的か明示的のどちらに指定されているかも異なることがある。

- \<property-LHS-declaration\> の宣言型は、その \<value-param\> 要素の宣言型である。
- Set プロパティ宣言の宣言型は、`Object` 、 `Variant` 、名前付きクラスで<ins>なければならない</ins>。
- モジュール内では、共通のプロシージャ名を持つ Let プロパティ宣言と \<property-get-declaration\> は同じ宣言型を<ins>持たなければならない</ins>。
- \<property-LHS-declaration\> の \<value-param\> に \<parameter-mechanism\> 要素がないか、キーワード `ByRef` からなる \<parameter-mechanism\> 要素がある場合、代わりにキーワード `ByVal` からなる \<parameter-mechanism\> 要素があるのと同じ意味を持つ。

実行時セマンティクス

- \<property-LHS-declaration\> の \<value-param\> は常に `ByVal` 仮引数の実行時セマンティクスを持つ。
- \<property-LHS-declaration\> に \<param-array\> 要素が含まれる場合、そのプロパティを呼び出す際に \<value-param\> に対応する実引数は、引数配列の要素に含まれない。

#### 5.3.1.8 イベントハンドラ宣言

```
event-handler-name = IDENTIFIER
```

静的セマンティクス

- プロシージャ宣言がイベントハンドラとして認められるのは、次のすべてが成立する場合である。
    - クラスモジュールに含まれている。
    - サブルーチン名の名称値は、プロシージャ宣言と同じクラスモジュール内の WithEvents 変数宣言に対応するイベントハンドラ名の接頭辞で<ins>始まらなければならない</ins>。対応する変数宣言で定義される変数をイベントハンドラの関連変数と呼ぶ。
    - イベントハンドラ名の接頭辞に続くプロシージャ名テキストは、関連変数の宣言型であるクラスで定義されたイベント名と<ins>同じでなければならない</ins>。対応する \<event-declaration\> が処理されるイベントである。
- 以下のいずれかに該当する場合、イベントハンドラは無効である。
    - プロシージャ宣言は \<subroutine-declaration\> ではない。
    - その \<parameter-list\> は、処理されるイベントの \<event-parameter-list\> と互換性がない。互換性のある \<parameter-list\> とは、以下の条件をすべて満たすものを指す。
        - \<positional-parameters\> 要素の数は<ins>同じでなければならない</ins>。
        - 対応する各仮引数は、同じ型及び仮引数機構を持つ。ただし、対応する仮引数は、名前と \<parameter-mechanism\> が暗黙的に指定されているか明示的に指定されているかで異なる場合がある。

#### 5.3.1.9 実装名宣言

```
implemented-name = IDENTIFIER
```

静的セマンティクス

- プロシージャ宣言は、次のすべてを満たす場合に実装名宣言とみなされる。
    - プロシージャ名は、同じクラスモジュール内の \<implements-directive\> で定義された実装インタフェース名の接頭辞で<ins>始まらなければならない</ins>。対応する \<implements-directive\> の \<class-type-name\> 要素で特定されるクラスをインタフェースクラスと呼ぶ。
    - 実装されたインタフェース名の接頭辞に続くプロシージャ名のテキストは、インタフェースクラスが定義する対応する公開の変数またはメソッドの名前と同じで<ins>なければならない</ins>。対応する変数やメソッドをインターフェイスメンバと呼ぶ。
    - インターフェースメンバが変数宣言である場合、実装されるメソッド宣言の候補はプロパティ宣言で<ins>なければならない</ins>。
    - インターフェースメンバがメソッド宣言である場合、実装されるメソッドの候補は同じ種類のメソッド宣言（\<function-declaration\>, \<subroutine-declaration\>, \<property-get-declaration\>, \<property-lhs-declaration\>）で<ins>なければらない</ins>。
- 対応するインタフェースメンバがメソッドである実装名宣言は、次の規則に従ってインタフェースメンバの\<procedure-parameters\> または \<property-parameters\> 要素と等価な \<procedure-parameters\> または \<property-parameters\> 要素を<ins>持たなければならない</ins>。
    - \<positional-parameters\>，\<optional-parameters\>，\<param-array\> 要素の数、対応する各仮引数の宣言型、対応する \<optional-parameters\> 要素の \<default-value\> の定数、および対応する各仮引数の実際の \<parameter-mechanism\> を含む \<parameter-list\> 要素を指定する。ただし、対応する \<parameter-list\> 要素は、仮引数名や \<parameter-mechanism\> が暗黙的に指定されているか明示的に指定されているかで異なる場合がある。
    - 対応するメンバが Set プロパティ宣言または Ge プロパティ宣言である場合、それらの \<value-param\> 要素は前述の規則に従って同等で<ins>なければならない</ins>。
- インターフェースメンバが関数宣言の場合、実装名宣言で定義された関数の宣言型とインターフェースメンバで定義された関数の宣言型は同じでなければならない。
- インタフェースメンバが変数で、実装名宣言がプロパティ宣言の場合、実装名宣言の宣言型は、インタフェースメンバの宣言型と<ins>同じでなければならない</ins>。

実行時セマンティクス

- 呼び出し先のオブジェクトの宣言型が、実際の呼び出し先のオブジェクトのクラスのインタフェースクラスであり、メソッド名がそのインタフェースクラスのメンバ名である場合、実際に呼び出されるメソッドは呼び出し先のオブジェクトのクラスの対応する実装メソッド宣言で定義されたメソッドとなる。

#### 5.3.1.10 ライフサイクルハンドラ宣言

```
lifecycle-handler-name = “Class_Initialize” / “Class_Terminate”
```

静的セマンティクス

- ライフサイクルハンドラ宣言とは以下の条件をすべて満たすサブルーチン宣言のことである。
    - クラスモジュールに含まれる。
    - プロシージャ名が \<lifecycle-handler-name\> である。
    - \<subroutine-declaration\> の \<procedure-parameters\> 要素が存在しないか、\<parameter-list\> 要素が含まれていない。

実行時セマンティクス

- クラスが Class_Initialize ライフサイクル ハンドラを定義する場合、インスタンスが New 演算子によって作成されるか、\<as-auto-object\> で宣言され現在の値が `Nothing` である 変数を参照するか、VBA 標準ライブラリの `CreateObject` 関数（セクション 6.1.2.8.1.4）を呼び出すことによって、その度にサブルーチンがメソッドとして呼び出される。
- クラスが Class_Terminate ライフサイクルハンドラを定義している場合、そのクラスのインスタンスが破棄されようとする度に、そのサブルーチンがメソッドとして呼び出される。呼び出される対象は破壊されようとしているオブジェクトである。オブジェクトの Class_Terminate ライフサイクルハンドラの呼び出しは、オブジェクトが VBA プログラムコードからアクセス不可になった時点で発生するが、プログラムの実行中に発生することもある。
- 状況によっては、Class_Terminate ライフサイクルハンドラによって、オブジェクトが明らかにアクセス不可になることがある。このような場合、オブジェクトは破壊されず、その候補でもなくなる。ただし、そのようなオブジェクトが後で再びアクセス不可になった場合にオブジェクトは破壊されるが、Class_Terminate ライフサイクルハンドラはそのターゲットオブジェクトに対して再び呼び出されることはない。言い換えれば、Class_Terminate ライフサイクルハンドラは、オブジェクトの生存期間中に最大 1 度だけ実行される。
- Class_Terminate ライフサイクルハンドラのエラー処理方針が呼び出し元のプロシージャのエラー処理方針を使用する場合、Class_Terminate ライフサイクルハンドラがデフォルトのエラー処理方針を使用しているかのような効果がある。つまり、Class_Terminate ライフサイクルハンドラで発生したエラーは、そのハンドラ自身でのみ処理することができる。

#### 5.3.1.11 プロシージャの実引数処理

プロシージャ呼び出しは、プロパティ、関数、サブルーチンに分類されるプロシージャ式、位置引数や名前引数からなる引数リスト、そしてプロシージャがクラスモジュールで定義されている場合は対象オブジェクトから構成される。

静的セマンティクス

- 呼び出し先で実引数リスト内に含まれる実引数式を引数とみなす。プロシージャ式がプロパティ、関数、サブルーチンに分類される場合、実引数リストは、参照するプロシージャ宣言で定義された仮引数との互換性を次のように静的にチェックされる。
    - まず、実引数は次のように仮引数にマッピングされる。
        - それぞれの位置指定実引数は、左から右の順にそれぞれの位置指定仮引数にマッピングされる。位置指定実引数が仮引数の数より多い場合、最後の仮引数が引数配列でない限り実引数リストには互換性がない。位置指定実引数が値を省略され、それにマッピングされた仮引数がオプションでない場合、名前指定実引数が後でこの仮引数にマッピングされたとしても実引数リストには互換性がない。
        - それぞれの名前指定実引数は、同じ名前の値を持つ仮引数にマッピングされる。同じ名前の値を持つ仮引数がない場合、あるいは 2 つ以上の名前指定または位置指定の実引数が同じ仮引数にマッピングされる場合、実引数リストには互換性がない。
    - 非オプションの仮引数に実引数がマッピングされていない場合、実引数リストには互換性がない。
    - マッピングされた各パラメータに対して下記が適用される。
        - 仮引数が `ByVal` の場合
            - 仮引数が特定のクラスまたは `Object` 以外の宣言型を持ち、マッピングされた実引数の宣言型から仮引数の宣言型への Let 互換でない場合、実引数リストには互換性がない。
            - 仮引数が特定のクラスまたは `Object` の宣言型を持ち、マッピングされた実引数の宣言型が特定のクラス、`Object`、`Variant` 以外の型である場合、実引数リストには互換性がない。
        - 仮引数が `ByRef` の場合
            - 仮引数が特定のクラス、`Object`、`Variant` 以外の宣言型を持ち、マッピングされた実引数の宣言型が仮引数の型と正確に一致しない場合、実引数リストには互換性がない。
            - 仮引数が特定のクラスまたは `Object` の宣言型を持ち、マッピングされた実引数の宣言型が特定のクラス、`Object` 以外の型である場合、実引数リストには互換性がない。
    - 実引数リストと仮引数リストに静的な互換性がない場合、プロシージャ呼び出しは無効となる。

実行時セマンティクス

- プロシージャ呼び出しの実行時セマンティクスは以下の通りである。
    - まず、実引数は次のように仮引数にマッピングされる。
        - 指定されたそれぞれの位置指定実引数は、左から右の順番でそれぞれの位置指定仮引数にマッピングされる。ただし、最後の仮引数が引数配列である場合、引数配列には、余分となった実引数を左から右の順に `Variant` 要素型として持つ下限が 0 の 新しい配列が設定される。位置指定実引数が値を省略して指定されており、そのマッピングされた仮引数がオプションではない場合、名前指定実引数が後でこの仮引数にマッピングされたとしても、ランタイムエラー 448（名前指定実引数が見つからない）が発生する。
        - それぞれの名前指定実引数は、同じ名称値を持つ仮引数にマッピングされる。同じ名称値を持つ仮引数がない場合、または 2 つ以上の名前指定実引数または位置指定実引数が同じ仮引数にマッピングされる場合、ランタイムエラー 448（名前指定実引数が見つからない）が発生する。
        - 最後の仮引数が引数配列で位置指定実引数が仮引数の数より少ない場合、引数配列には、下限が 0 上限が -1 で要素型が `Variant` の新しい配列が設定される。
    - オプションでない仮引数に実引数がマッピングされていない場合、ランタイムエラー 449（実引数がオプションではない）が発生する。
    - 各仮引数について、左から右の順に説明する。
        - 仮引数にマッピングされた実引数が存在しない場合、仮引数が `ByVal` の場合、仮引数が `ByRef` でマッピングされた実引数の式が値、関数、プロパティ、未束縛メンバに分類される場合は、呼び出されるプロシージャ内のプロシージャエクステントで仮引数と同じ名称値と宣言型を持つローカル変数が定義されて次のように値が代入される。
            - その仮引数がオプションでマッピングされた実引数がない場合、仮引数のデフォルト値が新しいローカル変数に割り当てられる。
            - その仮引数にマッピングされた実引数のデータ型が特定のクラスまたは `Nothing` 以外の場合、実引数のデータ値は新しいローカル変数に Let 割当される。
            - その仮引数にマッピングされた実引数のデータ型が特定のクラスまたは `Nothing` の場合、実引数のデータ値は新しいローカル変数に Set 割当される。
        - それ以外の、仮引数が `ByRef` でマッピングされた実引数の式が変数として分類される場合。
            - 仮引数の宣言型が特定のクラス、`Object` 、`Variant` 以外の場合、呼び出されるプロシージャ内で仮引数と同じ名前と宣言型を持ち、実引数の式で参照される変数への参照仮引数束縛が定義される。
            - 仮引数の宣言型が特定のクラスまたは `Object` である場合は以下の通り。
                - 形式的な宣言型が引数の式の宣言型と完全に一致する場合、そのプロシージャ内で実引数の式で参照される変数を参照される仮引数同じ名前と宣言された型の参照仮引数束縛が定義される。
                - 形式的な宣言型が、引数の式の宣言された型と正確に一致しない場合は以下の通り。
                    - ローカル変数は、仮引数と同じ名称値と宣言型でそのプロシージャ内のプロシージャエクステントで定義され、実引数の値は新しいローカル変数に Set 割当される。
                    - プロシージャが正常に終了する場合、ローカル変数内の値は実引数の参照変数に Set 割当で戻される。
            - 仮引数の宣言が `Variant` である場合、参照仮引数束縛は、そのプロシージャ内で仮引数と同じ名前で実引数の式による変数を参照した状態で定義される。この参照仮引数束縛は、Let 割当または Set 割当内の \<l-expression\> として使用される場合を除き、`Variant`の宣言型を持つものとして扱われる。
    - マッピングされていない各オプション仮引数に対して、仮引数と同じ名称値と宣言型を持つローカル変数がそのプロシージャ内のプロシージャエクステントで定義され、その値が次のように割り当てられる。
        - 仮引数に `Nothing` 以外のデフォルト値が指定されている場合、このデフォルト値は新しいローカル変数に Let 割当される。
        - 仮引数に `Nothing` のデフォルト値が指定されている場合、このデフォルト値は新しいローカル変数に Set 割当される。
        - 仮引数にデフォルト値が指定されていない場合、新しいローカル変数はその宣言型のデフォルト値で初期化される。
- ライブラリプロジェクトからインポートされたプロシージャを呼び出す際のパラメータ渡しのセマンティクスには、実装固有の差異が存在することがある。

## 5.4 プロシージャ本体とステートメント

プロシージャ本体には、VBA プロシージャのアルゴリズム動作を記述するステートメントが含まれている。プロシージャ本体には、ステートメントラベルの定義や、プロシージャ内で非公開に使用されるローカル変数の宣言も含まれる。

procedure-body = statement-block

静的セマンティクス

- \<statement-block\> 内のすべての \<statement-label-definition\> 要素および構文的に含まれる \<statement-block\> 要素のラベル値は<ins>一意でなければならない</ins>。
- \<procedure-body\> の \<statement-block\> 内にあるすべての \<statement-label-definition\> 要素のラベルは、それを含むプロシージャ宣言の \<end-label\> のラベルとは異なる値で<ins>なければならない</ins>。

### 5.4.1 ステートメントブロック

ステートメントブロックは 0 個以上のステートメントを並べたものである。

```
statement-block = *(block-statement EOS)

block-statement = statement-label-definition / rem-statement / statement

statement = control-statement / data-manipulation-statement / error-handling-statement / file-statement
```

実行時セマンティクス

- \<statement-block\> に含まれる最初の \<block-statement\> の実行から始まり、最後に含まれる \<block-statement\> が実行されるか、\<control-statement\> によって \<statement-block\> に含まれない \<statement-label-definition\> に明示的に移行するまで順次処理される。
- \<statement-block\> の実行は、\<control-statement\> が \<statement-block\> に含まれる \<statement-label-definition\> に実行を移すことで始めることができる。その場合、逐次処理は対象の \<statement-label-definition\> から始まり、対象の \<statement-label-definition\> に先行する \<block-statement\> 要素は実行されない。
- \<statement-block\> 内の \<control-statement\> 要素は、同じ \<statement-block\> 内に含まれる \<statement-label-definition\> に現在の実行位置を転送することによって、逐次処理の実行順序を変更することができる。
- 行頭の ":" に続く識別子は、常に \<statement\> ではなく \<statement-label-definition\> として解釈される。

#### 5.4.1.1 ステートメントラベル

```
statement-label-definition = LINE-START ((identifier-statement-label “:”) / (line-number-label [“:”] ))
statement-label = identifier-statement-label / line-number-label
statement-label-list = statement-label [“,” statement-label]
identifier-statement-label = IDENTIFIER
line-number-label = INTEGER
```

静的セマンティクス

- \<identifier-statement-label\> の \<IDENTIFIER\> の名称値が "Randomize" でない可能性がある。\<statement-label\> が \<INTEGER\> の場合、そのデータ値は 0 から 2,147,483,647 の範囲に<ins>含まれなければならない</ins>。
- \<statement-label-definition\> のラベル値は構成要素である \<identifier-statement-label\> または \<line-number-label\> のラベル値である。
- \<statement-label\> のラベル値は構成要素である \<identifier-statement-label\> または \<line-number-label\> のラベル値である。
- \<identifier-statement-label\> のラベル値は構成要素である \<IDENTIFIER\> の名称値である。
- \<line-number-label\> のラベル値は \<INTEGER\> 要素のデータ値である。
- \<statement-label-definition\> に同じラベル値を含むプロシージャ宣言が複数ある場合はエラーとなる。

実行時セマンティクス

- \<statement-label-definition\> を実行しても観測できるような効果はない。

#### 5.4.1.2 Rem ステートメント

\<rem-statement\> には、プログラムに影響を与えないプログラム解説のためのテキストが含まれている。

```
rem-statement = "Rem" comment-body
```

実行時セマンティクス

- \<rem-statement\> を実行しても観測できるような効果はない。

### 5.4.2 制御ステートメント

制御ステートメントは、プログラム内の実行の流れを決定する。

```
control-statement = if-statement / control-statement-except-multiline-if

control-statement-except-multiline-if = call-statement / while-statement / for-statement / exit-for-statement / do-statement / exit-do-statement / single-line-if-statement /  select-case-statement /stop-statement / goto-statement / on-goto-statement / gosub-statement / return-statement / on-gosub-statement /for-each-statement / exit-sub-statement / exit-function-statement / exit-property-statement / raiseevent-statement / with-statement
```

#### 5.4.2.1 Call ステートメント

\<call-statement\> はサブルーチンや関数を呼び出し、戻り値を破棄する。

```
call-statement = "Call" (simple-name-expression / member-access-expression / index-expression / with-expression)
call-statement =/ (simple-name-expression / member-access-expression / with-expression) argument-list 
```

静的セマンティクス

- `Call` キーワードが省略された場合、位置指定実引数がもしある場合は空白が直前にある場合にのみ<with-expression> を表すことができる。
- 指定された実引数リストは次のように決定される。
    - `Call` キーワードを指定した場合。
        - \<call-statement\> 要素の参照された式が \<index-expression\> の場合、指定された実引数リストはこの式の実引数リストである。
        - それ以外の場合は、空の引数リストとなる。
    - `Call`キーワードが省略された場合は、指定された実引数リストは \<argument-list\> となる。
- \<call-statement\> は以下のいずれかに該当する場合に無効となる。
    - 参照された式が、変数、関数、サブルーチン、未束縛メンバとして分類されない。
    - 参照された式が変数に分類され、かつ以下のいずれかに該当する場合。
        - 参照された式の宣言型が、特定のクラスまたは `Object` 以外の型である。
        - 参照された式の宣言型が、デフォルト関数またはサブルーチンを持たない特定のクラスである。
        - 参照された式の宣言型が、デフォルトの関数またはサブルーチンを持つ特定のクラスで、その仮引数リストが指定された実引数リストと互換性がない。
    - 参照された式が関数またはサブルーチンとして分類され、そのプロシージャの仮引数リストが、指定された実引数リストと互換性がない。

実行時セマンティクス

- 実行時には、以下のように式により参照されるプロシージャが呼び出される。
    - 式が未束縛メンバとして分類された場合、そのメンバは変数、プロパティ、関数、サブルーチンとして解決され、式がそれぞれ変数式、プロパティ式、関数式、サブルーチン式として静的に解決されていたかのように評価が継続される。
    - 式が関数またはサブルーチンとして分類された場合、指定された実引数リストで式の参照先プロシージャが呼び出される。呼び出しの結果得られた戻り値はすべて破棄される。
    - 式が変数に分類される場合は下記の通り。
        - 式のデータ値が、公開されているデフォルト関数またはサブルーチンを持つオブジェクトである場合、このデフォルトプロシージャは指定された実引数リストで呼び出される。
        - 式のデータ値が公開されたデフォルトプロパティを持つオブジェクトである場合、ランタイムエラー 450 （実引数の数が正しくないかプロパティの割り当てが無効）が発生する。
        - それ以外の場合は、ランタイムエラー 438（オブジェクトがプロパティまたはメソッドをサポートしていない）が発生する。
    - 式がプロパティに分類される場合、ランタイムエラー 450（実引数の数が正しくないかプロパティの割り当てが無効）が発生する。

#### 5.4.2.2 While ステートメント

\<while-statement\> は、指定された前提条件が True である限り一連のステートメントを実行する。

```
while-statement = "While" boolean-expression EOS  statement-block  "Wend"
```

実行時セマンティクス

<boolean-expression> は、評価値がデータ値 False になるまで繰り返し評価される。\<boolean-expression\> の評価値がデータ値 True になるたびに、\<statement-block\> は \<boolean-expression\> の次の評価の前に実行される。

#### 5.4.2.3 For ステートメント

\<for-statement\> は、一連のステートメントを指定された回数だけ実行する。

```
for-statement = simple-for-statement / explicit-for-statement

simple-for-statement = for-clause EOS statement-block "Next"

explicit-for-statement = for-clause EOS statement-block
(“Next” / (nested-for-statement “,”)) bound-variable-expression
nested-for-statement = explicit-for-statement / explicit-for-each-statement
for-clause = “For” bound-variable-expression “=” start-value “To” end-value [step-clause]
start-value = expression
end-value = expression
step-clause = Step" step-increment
step-increment = expression
```

静的セマンティクス

- \<step-clause\> が存在しない場合、\<step-increment\> の値は整数データ値 1 である。
- \<explicit-for-statement\> の \<for-clause\> 内の \<bound-variable-expression\> は、\<statement-block\> に続く \<bound-variable-expression\> と同じ変数に<ins>解決しなければならない</ins>。\<bound-variable-expression\> の宣言型は、数値型または `Variant` で<ins>なければならない</ins>。
- \<start-value\>, \<end-value\>, \<step-increment\> の宣言型は、`Double` に静的に `Let` 強制可能で<ins>なければならない</ins>。

実行時セマンティクス

- \<start-value\>, \<end-value\>, \<step-increment\> の各式は、以下のいずれの計算の前にも一度だけ順番に評価される。\<start-value\>, \<end-value\>, \<step-increment\> の値が `Double` に `Let` 互換でない場合、直ちにエラー 13（型不一致）が発生する。そうでなければ、元の `Let` 互換でない値を用いて次のアルゴリズムを進める。
- \<for-statement\> の実行は以下のアルゴリズムに従って進められる。
    1. \<step-increment\> のデータ値が 0 以上の数で、\<bound-variable-expression\> の値が \<end-value\> の値より大きい場合、\<for-statement\> の実行は直ちに終了する。それ以外の場合、ステップ 2 へ進む。
    2. \<step-increment\> のデータ値が 0 未満の数で、\<bound-variable-expression\> の値が \<end-value\> の値より小さい場合、\<for-statement\> の実行は直ちに終了する。それ以外の場合、ステップ 3 へ進む。
    3. \<statement-block\> が実行される。次に、\<nested-for-statement\> がある場合はそれが実行される。最後に、\<step-increment\> の値に \<bound-variable-expression\> の値を加え、\<bound-variable-expression\> に Let 割当する。その後、実行はステップ 1 から繰り返される。
- \<for-statement\> の外に定義された \<goto-statement\> によって \<statement-block\> 内の \<statement\> が実行された場合、\<start-value\>, \<end-value\>, \<step-increment\> の式は評価されない。そのプロシージャの実行中に \<start-value\>, \<end-value\>, \<step-increment\> を評価しないまま \<statement-block\> の実行が終了して \<statement-block\> の終端に達すると、エラーコード 92 （For ループが未初期化）を発生させる。これは、\<statement-block\> に \<bound-variable-expression\> を明示的に初期化する代入式が含まれていても発生する。それ以外の場合で、\<start-value\>, \<end-value\>, \<step-increment\> 式がすでに評価されていれば、\<for-statement\> の実行のために定義された規則に従ってステップ 3 でアルゴリズムは継続される。
- \<for-statement\> の実行が終了しても、\<bound-variable-expression\> の値はループが終了した時点の値のままである。

#### 5.4.2.4 For Each ステートメント

\<for-each-statement\> は、コレクションの各要素に対して一度ずつ一連のステートメントを実行する。

```
for-each-statement = simple-for-each-statement / explicit-for-each-statement

simple-for-each-statement = for-each-clause EOS statement-block “Next”

explicit-for-each-statement = for-each-clause EOS statement-block
(“Next” / (nested-for-statement “,”)) bound-variable-expression

for-each-clause = “For” “Each” bound-variable-expression “In” collection
collection = expression
```

静的セマンティクス

- \<explicit-for-each-statement\> の \<for-each-clause\> 内の \<bound-variable-expression\> は、キーワード `Next` に続く \<bound-variable-expression\> と同じ変数に<ins>解決しなければならない</ins>。
- \<collection\> の宣言型が配列の場合、\<bound-variable-expression\> の宣言型は `Variant` で<ins>なければならない</ins>。

実行時セマンティクス

- \<collection\> 式は、以下の計算の前に一度だけ評価される。
- \<collection\> のデータ値が配列の場合。
    - 配列に要素がない場合、\<for-each-statement\> の実行は直ちに終了する。
    - もし配列の宣言型が `Object` なら、\<bound-variable-expression\> は配列の最初の要素に Set 割当される。それ以外の場合、\<bound-variable-expression\> は配列の最初の要素に Let 割当される。
    - \<bound-variable-expression\> が設定された後、\<statement-block\> が実行される。\<nested-for-statement\> がある場合はそれが実行される。
    - \<statement-block\> と \<nested-for-statement\> の実行が終了すると、\<bound-variable-expression\> は配列の次の要素に Let 割当 される（オブジェクト配列であれば Set 割当される）。配列にそれ以上要素がない場合のみ、\<for-each-statement\> の実行は直ちに終了する。そうでなければ、\<statement-block\> が再び実行され、\<nested-for-statement\> があればそれが続き、このステップが繰り返される。
    - \<for-each-statement\> の実行が終了すると、\<bound-variable-expression\> の値は、配列の最後の要素のデータ値になる。
- \<collection\> のデータ値が配列ではない場合。
    - \<collection\> のデータ値は、実装定義の列挙インタフェースをサポートする外部オブジェクトへのオブジェクト参照で<ins>なければならない</ins\>。\<bound-variable-expression\> は、実装定義された方法で \<collection\> の最初の要素に Let 割当または Set 割当される。
    - \<bound-variable-expression\> が設定された後、\<statement-block\> が実行される。\<nested-for-statement\> がある場合はそれが実行される。
    - \<statement-block\> と \<nested-for-statement\> の実行が完了すると、\<bound-variable-expression\> は \<collection\> の次の要素に実装定義された方法で Set 割当される。\<collection\> にそれ以上要素がない場合、\<for-each-statement\> の実行は直ちに終了する。そうでなければ、\<statement-block\> が再び実行され、\<nested-for-statement\> があればそれが続き、このステップが繰り返される。
    - \<for-each-statement\> の実行が終了すると、\<bound-variable-expression\> の値は \<collection\> の最後の要素のデータ値となる。
- \<for-each-statement\> の外部で定義された \<goto-statement\> が \<statement-block\> 内の \<statement\> を実行させる場合、\<collection\> 式は評価されない。そのプロシージャよ実行中に \<collection\> を評価しないまま \<statement-block\> の実行が終了し、\<statement-block\> の終端に到達すると、エラーコード 92（For ループが未初期化）が発生する。これは、\<statement-block\> に \<bound-variable-expression\> を明示的に初期化する代入式が含まれていても発生する。それ以外の場合、もし式 \<collection\> がすでに評価されていれば、アルゴリズムは \<collection\> に対する \<for-each-statement\> の実行のために定義された規則に従って継続される。

##### 5.4.2.4.1 配列の列挙順序

- 配列の要素を列挙するとき、インデックスは常にそれぞれの次元の下限となる要素を最初の要素とする。
- 次の要素は、左端の次元で配列インデックスをインクリメントすることによって取得される。インクリメントして上限を超えた場合、その次元は下限に設定されてすぐ右隣の次元がインクリメントされる。
- 最後の要素は、すべてのインデックスがそれぞれの次元の上限である要素として定義される。

